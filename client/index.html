<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Adventures of the Yeah, Yeah Man</title>
  <style>
    :root {
      --ink: #0f0f14;
      --cream: #f6f1e8;
      --neon: #ffb200;
      --heat: #ff5a4f;
      --electric: #4ad9d9;
      --shadow: rgba(10, 10, 18, 0.55);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", sans-serif;
      background:
        radial-gradient(circle at 20% 20%, rgba(255, 90, 79, 0.25), transparent 45%),
        radial-gradient(circle at 80% 10%, rgba(74, 217, 217, 0.2), transparent 35%),
        linear-gradient(140deg, #111018 0%, #231d2f 45%, #1b222e 100%);
      color: var(--cream);
      overflow: hidden;
      height: 100vh;
    }

    #stage {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: transparent;
    }

    .is-touch #stage {
      padding-bottom: 20vh;
    }

    .is-touch canvas {
      height: calc(100% - 20vh);
    }

    @media (max-height: 420px) {
      .is-touch #stage {
        padding-bottom: 24vh;
      }

      .is-touch canvas {
        height: calc(100% - 24vh);
      }

      #touch-controls {
        bottom: 10px;
      }

      #dpad {
        grid-template-columns: 46px 46px 46px;
        grid-template-rows: 46px 46px 46px;
      }

      #dpad button,
      #dpad-center {
        width: 46px;
        height: 46px;
      }

      #action-buttons button {
        width: 52px;
        height: 52px;
        font-size: 16px;
      }
    }

    #hud {
      position: absolute;
      top: 44px;
      left: 20px;
      right: 20px;
      z-index: 2;
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 700;
    }

    #hud-title {
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      font-family: "Impact", "Arial Black", sans-serif;
      font-size: clamp(18px, 2.4vw, 28px);
      font-weight: 900;
      color: var(--neon);
      text-shadow: 0 10px 18px var(--shadow);
      letter-spacing: 0.06em;
      pointer-events: none;
      white-space: nowrap;
    }

    #voice-toggle {
      pointer-events: auto;
      background: rgba(18, 16, 24, 0.8);
      color: var(--cream);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 8px 10px;
      font-weight: 800;
      letter-spacing: 0.08em;
      cursor: pointer;
      box-shadow: 0 10px 20px var(--shadow);
    }

    #voice-toggle:active {
      transform: translateY(1px) scale(0.98);
    }

    #hud .score {
      font-size: 14px;
      background: rgba(18, 16, 24, 0.75);
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 10px 20px var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    #meter {
      flex: 1;
      max-width: 360px;
      min-width: 160px;
      height: 22px;
      border-radius: 999px;
      background: rgba(15, 15, 20, 0.65);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.45);
      box-shadow: 0 10px 20px var(--shadow);
      position: relative;
    }

    #meter-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--neon), var(--heat));
      transition: width 0.1s ease-out;
      box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.3);
    }

    #meter-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.08em;
      color: rgba(246, 241, 232, 0.95);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
    }

    #burst-counter {
      pointer-events: none;
      background: rgba(18, 16, 24, 0.75);
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 10px 20px var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 12px;
    }

    #overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(11, 10, 18, 0.5);
      backdrop-filter: blur(6px);
      text-align: center;
      padding: 24px;
      z-index: 6;
    }

    #overlay.hidden {
      display: none;
    }

    #title {
      font-family: "Impact", "Arial Black", sans-serif;
      font-size: clamp(32px, 6vw, 72px);
      margin: 0;
      color: var(--neon);
      text-shadow: 0 16px 30px var(--shadow);
      letter-spacing: 0.04em;
    }

    #subtitle {
      margin: 12px 0 0;
      font-size: clamp(14px, 2.4vw, 20px);
      max-width: 520px;
      color: rgba(246, 241, 232, 0.85);
    }

    #controls {
      margin-top: 22px;
      font-size: 13px;
      opacity: 0.8;
    }

    #death-reason {
      margin-top: 10px;
      font-weight: 700;
      color: rgba(246, 241, 232, 0.9);
    }

    #restart-btn {
      margin-top: 16px;
      font-family: inherit;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      background: var(--neon);
      color: #141018;
      border: none;
      border-radius: 999px;
      padding: 12px 22px;
      cursor: pointer;
      box-shadow: 0 12px 24px var(--shadow);
    }

    #restart-btn:active {
      transform: translateY(1px) scale(0.98);
    }

    #touch-controls {
      position: fixed;
      left: 16px;
      right: 16px;
      bottom: 16px;
      display: none;
      align-items: flex-end;
      justify-content: space-between;
      pointer-events: auto;
      gap: 10px;
      touch-action: none;
      z-index: 5;
    }

    .is-dead #touch-controls {
      display: none;
    }

    #action-buttons button,
    #dpad button {
      font-family: inherit;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(22, 20, 30, 0.9);
      color: var(--cream);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 16px;
      padding: 10px 14px;
      box-shadow: 0 12px 24px var(--shadow);
      touch-action: none;
      user-select: none;
    }

    #action-buttons {
      display: flex;
      flex-direction: column-reverse;
      gap: 8px;
      align-items: flex-end;
    }

    #action-buttons button {
      width: 58px;
      height: 58px;
      font-size: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.2);
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
    }

    #action-buttons button:nth-child(1) {
      background: linear-gradient(135deg, #6b3fb8, #b386ff);
    }

    #action-buttons button:nth-child(2) {
      background: linear-gradient(135deg, #9a5ed8, #e0b6ff);
      transform: translateX(-8px);
    }

    #dpad {
      display: grid;
      grid-template-columns: 52px 52px 52px;
      grid-template-rows: 52px 52px 52px;
      grid-template-areas:
        ". up ."
        "left center right"
        ". down .";
      gap: 6px;
      padding: 6px;
      border-radius: 20px;
      background: rgba(28, 26, 36, 0.8);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
    }

    #dpad button {
      width: 52px;
      height: 52px;
      border-radius: 10px;
      background: rgba(18, 16, 24, 0.95);
    }
    #dpad-up {
      grid-area: up;
    }
    #dpad-left {
      grid-area: left;
    }
    #dpad-right {
      grid-area: right;
    }
    #dpad-down {
      grid-area: down;
    }
    #dpad-center {
      grid-area: center;
      width: 52px;
      height: 52px;
      border-radius: 12px;
      background: rgba(12, 12, 18, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 0 12px rgba(0, 0, 0, 0.4);
    }

    #touch-controls button:active {
      transform: translateY(1px) scale(0.98);
    }

    .is-touch #touch-controls {
      display: flex;
    }

    @media (max-width: 700px) {
      #hud {
        flex-direction: column;
        align-items: stretch;
      }

      #hud .score {
        width: 100%;
        text-align: center;
      }

      #meter {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="game" aria-label="Stoop Runner"></canvas>

    <div id="hud">
      <div id="hud-title">The Adventures of the Yeah, Yeah Man</div>
      <div class="score">Score: <span id="score">0</span></div>
      <div id="meter" aria-label="Addiction meter">
        <div id="meter-fill"></div>
        <div id="meter-text">100</div>
      </div>
      <div class="score">Addiction: <span id="meter-value">100%</span></div>
      <div id="burst-counter">Burst: <span id="burst-count">0</span></div>
      <button id="voice-toggle" type="button" aria-label="Toggle voice">Voice On</button>
    </div>

    <div id="overlay">
      <div>
        <h1 id="title">The Adventures of the Yeah, Yeah Man</h1>
        <p id="subtitle">Sprint the block. Dodge roaches. Grab the stash to keep your meter alive.</p>
        <div id="death-reason"></div>
        <div id="controls">Desktop: A-D to move, Space to jump, left click/F to fire, G for burst, right click for belt. Mobile: D-pad to move/jump, A to shoot, B to release flower power.</div>
        <button id="restart-btn" type="button">New Game</button>
      </div>
    </div>

    <div id="touch-controls">
      <div id="dpad">
        <button id="dpad-up" type="button">Up</button>
        <button id="dpad-right" type="button">Right</button>
        <button id="dpad-left" type="button">Left</button>
        <button id="dpad-down" type="button">Down</button>
        <div id="dpad-center" aria-hidden="true"></div>
      </div>
      <div id="action-buttons">
        <button id="fire-btn" type="button">A</button>
        <button id="burst-btn" type="button">B</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const hudScore = document.getElementById("score");
    const meterFill = document.getElementById("meter-fill");
    const meterText = document.getElementById("meter-text");
    const meterValueLabel = document.getElementById("meter-value");
    const burstCount = document.getElementById("burst-count");
    const overlay = document.getElementById("overlay");
    const deathReason = document.getElementById("death-reason");
    const fireBtn = document.getElementById("fire-btn");
    const burstBtn = document.getElementById("burst-btn");
    const dpad = document.getElementById("dpad");
    const dpadUp = document.getElementById("dpad-up");
    const dpadLeft = document.getElementById("dpad-left");
    const dpadRight = document.getElementById("dpad-right");
    const dpadDown = document.getElementById("dpad-down");
    const restartBtn = document.getElementById("restart-btn");
    const voiceToggle = document.getElementById("voice-toggle");

    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    const isDesktop = !isTouch;
    const voicePreference = {
      name: "David"
    };
    let cachedVoice = null;
    if (isTouch) {
      document.body.classList.add("is-touch");
    }

    const input = {
      jumpQueued: false,
      fireQueued: false,
      beltQueued: false,
      left: false,
      right: false,
      down: false
    };

    const world = {
      width: 0,
      height: 0,
      groundY: 0,
      scale: 1
    };

    const player = {
      x: 0,
      y: 0,
      w: 36,
      h: 52,
      vy: 0,
      vx: 0,
      facing: 1,
      jumpsLeft: 1,
      color: "#f6f1e8",
      standH: 52,
      ducking: false
    };

    const levelConfigs = [
      { label: "SNAP OFFICE", endX: 7800 },
      { label: "TANF CENTER", endX: 18000 },
      { label: "WIC OFFICE", endX: 19600 },
      { label: "MEDICAID CLINIC", endX: 21000, boss: { name: "REPO CHIEF", hp: 18, fireRate: 3.2, followUp: 1.1, speed: 90, jumpRate: 4.5, shirt: "#3a2f4b", sign: "#f6f1e8" } },
      { label: "SECTION 8", endX: 22000, boss: { name: "TOW CAPTAIN", hp: 20, fireRate: 3.0, followUp: 1.0, speed: 92, jumpRate: 4.3, shirt: "#2d364b", sign: "#ffe6a7" } },
      { label: "CHIP OFFICE", endX: 23000, boss: { name: "SWEEP BOSS", hp: 22, fireRate: 2.8, followUp: 0.9, speed: 95, jumpRate: 4.1, shirt: "#2d4b3a", sign: "#f6f1e8" } },
      { label: "HEAD START", endX: 24000, boss: { name: "TICKET MASTER", hp: 24, fireRate: 2.7, followUp: 0.9, speed: 98, jumpRate: 3.9, shirt: "#4b2d2d", sign: "#e5f4ff" } },
      { label: "LIHEAP OFFICE", endX: 25000, boss: { name: "CODE ENFORCER", hp: 26, fireRate: 2.6, followUp: 0.8, speed: 100, jumpRate: 3.8, shirt: "#44304b", sign: "#fff0cc" } },
      { label: "SSI SERVICES", endX: 26000, boss: { name: "BLOCK CAPTAIN", hp: 28, fireRate: 2.5, followUp: 0.8, speed: 102, jumpRate: 3.7, shirt: "#2f4b4b", sign: "#f6f1e8" } },
      { label: "HUD OFFICE", endX: 27000, boss: { name: "NIGHT WATCH", hp: 30, fireRate: 2.4, followUp: 0.8, speed: 104, jumpRate: 3.6, shirt: "#4b3a2d", sign: "#ffe6a7" } },
      { label: "CCDF CENTER", endX: 28000, boss: { name: "METER MAID", hp: 32, fireRate: 2.3, followUp: 0.7, speed: 106, jumpRate: 3.5, shirt: "#2d3e4b", sign: "#f6f1e8" } },
      { label: "EITC HUB", endX: 29000, boss: { name: "ZONE MARSHAL", hp: 34, fireRate: 2.2, followUp: 0.7, speed: 108, jumpRate: 3.4, shirt: "#3b2d4b", sign: "#ffe6a7" } },
      { label: "CSBG OFFICE", endX: 30000, boss: { name: "CURFEW CHIEF", hp: 36, fireRate: 2.1, followUp: 0.6, speed: 110, jumpRate: 3.3, shirt: "#2d3a4b", sign: "#f6f1e8" } }
    ];

    const state = {
      running: false,
      dead: false,
      moveSpeed: 240,
      score: 0,
      meter: 100,
      meterDrain: 3,
      meterAdd: 20,
      gravity: 1600,
      jumpPower: 640,
      time: 0,
      lastSpawn: 0,
      lastCollectible: 0,
      lastPlatform: 0,
      lastObstacleX: 0,
      lastCollectibleX: 0,
      lastPlatformX: 0,
      lastFrame: performance.now(),
      distance: 0,
      cameraX: 0,
      collectMessageTimer: 0,
      fireMessageTimer: 0,
      deathCause: "",
      deathDetail: "",
      initialDropTimer: 0,
      starsSpawned: 0,
      level: 1,
      levelEndX: 15600,
      goalLabel: "TRAP HOUSE",
      burstCharges: 0,
      enemyShotTimer: 0,
      billManActive: false,
      billManStage: 0,
      billManX: 0,
      billManY: 0,
      billManHp: 20,
      billManW: 56,
      billManH: 90,
      billManMidX: 0,
      billManEndX: 0,
      levelOneBillTriggerX: 0,
      levelOneBillTriggerX2: 0,
      billRocketTimer: 0,
      billFollowUpTimer: 0,
      billJumpTimer: 0,
      billJumpOffset: 0,
      billMoveSpeed: 90,
      billFireRate: 3,
      billFollowUp: 1,
      billJumpRate: 4.5,
      levelOneAirTimer: 0,
      levelOneAirBurstTimer: 0,
      levelOneTraps: [],
      beltTimer: 0,
      kidX: 0,
      kidY: 0,
      kidHits: 0,
      kidAlive: true,
      kidDucking: false,
      kidBurstTimer: 0,
      kidBurstCount: 0,
      lastPlant: 0,
      plantsSpawned: 0,
      invincibleTimer: 0,
      copCarActive: false,
      copCars: [],
      copCarTimer: 0,
      copCarSpawnTimer: 0,
      copHitCooldown: 0,
      lastPlatformY: 0,
      dogsActive: false,
      dogsX: 0,
      dogs: [],
      copBossActive: false,
      copBossX: 0,
      copBossY: 0,
      copBossHp: 10,
      copBossFireTimer: 0,
      copBossJumpTimer: 0,
      copBossJumpOffset: 0,
      billLabel: "BILL MAN",
      billShirt: "#2c2b30",
      billSign: "#f6f1e8",
      voiceEnabled: true,
      spokenStart: false
    };

    const obstacles = [];
    const platforms = [];
    const collectibles = [];
    const fireballs = [];
    const plants = [];
    const enemyShots = [];
    const billRockets = [];
    const billFireballs = [];
    const stars = [];
    let hasUserInteracted = false;

    function resize() {
      const ratio = window.devicePixelRatio || 1;
      world.width = window.innerWidth;
      world.height = window.innerHeight;
      world.groundY = world.height * 0.58;
      world.scale = ratio;
      canvas.width = world.width * ratio;
      canvas.height = world.height * ratio;
      canvas.style.width = `${world.width}px`;
      canvas.style.height = `${world.height}px`;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

      const isMobile = isTouch || world.width < 900;
      player.w = isMobile ? 30 : 40;
      player.h = isMobile ? 46 : 58;
      player.x = Math.max(player.x, 120);
      player.y = world.groundY - player.h;
      state.jumpPower = isMobile ? 620 : 720;
      state.moveSpeed = isMobile ? 220 : 260;
    }

    function resetGame(nextLevel = state.level) {
      state.level = nextLevel;
      state.running = true;
      state.dead = false;
      state.score = 0;
      state.meter = 100;
      state.time = 0;
      state.lastSpawn = 0;
      state.lastCollectible = 0;
      state.lastPlatform = 0;
      state.lastObstacleX = 0;
      state.lastCollectibleX = 0;
      state.lastPlatformX = 0;
      state.distance = 0;
      state.cameraX = 0;
      state.deathCause = "";
      state.burstCharges = 0;
      state.enemyShotTimer = 0;
      state.billManActive = false;
      state.billManStage = 0;
      state.billManX = 0;
      state.billManY = 0;
      state.billManHp = 20;
      state.billRocketTimer = 0;
      state.billFollowUpTimer = 0;
      state.billJumpTimer = 0;
      state.billJumpOffset = 0;
      state.lastPlant = 0;
      state.kidHits = 0;
      state.kidAlive = true;
      state.kidBurstTimer = 0;
      state.kidBurstCount = 0;
      state.invincibleTimer = 0;
      state.plantsSpawned = 0;
      input.left = false;
      input.right = false;
      input.down = false;
      input.jumpQueued = false;
      input.fireQueued = false;
      input.beltQueued = false;
      state.copCarActive = false;
      state.copCars = [];
      state.copCarTimer = 0;
      state.copCarSpawnTimer = 0;
      state.copHitCooldown = 0;
      state.lastPlatformY = 0;
      state.dogsActive = false;
      state.dogsX = 0;
      state.dogs = [];
      state.copBossActive = false;
      state.copBossX = 0;
      state.copBossY = 0;
      state.copBossHp = 10;
      state.copBossFireTimer = 0;
      state.copBossJumpTimer = 0;
      state.copBossJumpOffset = 0;
      state.billLabel = state.level === 2 ? "DFAC" : "BILL MAN";
      const levelConfig = levelConfigs[state.level - 1];
      if (state.level === 2) {
        state.billShirt = "#1f2a44";
        state.billSign = "#f6f1e8";
      } else if (levelConfig && levelConfig.boss) {
        state.billLabel = levelConfig.boss.name;
        state.billShirt = levelConfig.boss.shirt;
        state.billSign = levelConfig.boss.sign;
      } else {
        state.billShirt = "#2c2b30";
        state.billSign = "#f6f1e8";
      }
      if (levelConfig && levelConfig.boss) {
        state.billManHp = levelConfig.boss.hp;
        state.billMoveSpeed = levelConfig.boss.speed;
        state.billFireRate = levelConfig.boss.fireRate;
        state.billFollowUp = levelConfig.boss.followUp;
        state.billJumpRate = levelConfig.boss.jumpRate;
      } else {
        state.billMoveSpeed = 90;
        state.billFireRate = 3;
        state.billFollowUp = 1;
        state.billJumpRate = 4.5;
      }
      state.spokenStart = false;
      state.deathDetail = "";
      obstacles.length = 0;
      platforms.length = 0;
      collectibles.length = 0;
      fireballs.length = 0;
      plants.length = 0;
      enemyShots.length = 0;
      billRockets.length = 0;
      billFireballs.length = 0;
      stars.length = 0;
      player.x = 160;
      player.y = world.groundY - player.h;
      player.vy = 0;
      player.vx = 0;
      player.jumpsLeft = 1;
      player.standH = player.h;
      player.ducking = false;
      overlay.classList.add("hidden");
      document.body.classList.remove("is-dead");
      restartBtn.textContent = "New Game";
      state.initialDropTimer = state.level === 1 ? 0 : 3;
      state.copCarTimer = 5;
      state.copCarSpawnTimer = 0;
      state.copHitCooldown = 0;
      state.lastPlatformY = world.groundY - 160;
      state.starsSpawned = 0;
      state.levelEndX = levelConfig ? levelConfig.endX : 15600;
      state.goalLabel = levelConfig ? levelConfig.label : "TRAP HOUSE";
      if (state.level === 1) {
        state.billManMidX = state.levelEndX * 0.5 + world.width * 0.6;
        state.billManEndX = state.levelEndX - 240;
      state.billManStage = 0;
      state.billManActive = false;
      state.billManX = state.billManMidX;
      state.billManY = world.groundY - 84;
      state.levelOneBillTriggerX = 0;
      state.levelOneBillTriggerX2 = 0;
      state.levelOneAirTimer = 0;
      state.levelOneAirBurstTimer = 0;
      state.levelOneTraps = [];
      } else {
        state.billManMidX = state.levelEndX * 0.5 + world.width * 0.6;
        state.billManEndX = 0;
      state.billManX = state.billManMidX;
      state.billManY = world.groundY - 84;
      state.levelOneBillTriggerX = 0;
      state.levelOneBillTriggerX2 = 0;
      state.levelOneAirTimer = 0;
      state.levelOneAirBurstTimer = 0;
      state.levelOneTraps = [];
      }
      if (state.level === 2) {
        state.copBossActive = true;
        state.copBossX = player.x + 260;
        state.copBossY = world.groundY - 88;
        state.copBossFireTimer = state.time;
      }
      seedPlatformsForLevel(state.level);
      if (state.level !== 1) {
        platforms.push({
          x: player.x + 240,
          y: world.groundY - 140,
          w: 90,
          h: 14,
          isQuestion: false,
          used: false,
          hasStar: false
        });
        addAccessSteps(platforms[platforms.length - 1]);
      }
      const mainRowY = world.groundY - 140;
      if (state.level === 1) {
        platforms.push({
          x: player.x + 160,
          y: mainRowY,
          w: 52,
          h: 14,
          isQuestion: true,
          used: false,
          hasStar: true,
          spawnsPlant: true,
          tint: "#2faa59"
        });
        const step = createPlatform(player.x + 260, world.groundY - 60, 46, 14);
        step.tint = "#c54b4b";
        platforms.push(step);
        const upper = createPlatform(player.x + 330, mainRowY, 4 * 36, 14);
        platforms.push(upper);
        state.levelOneBillTriggerX = upper.x + upper.w + 40;
        obstacles.push({
          x: player.x + 260,
          y: world.groundY - 30,
          w: 34,
          h: 30,
          type: "roach",
          speed: 80,
          vx: -1,
          phase: Math.random() * Math.PI * 2,
          hp: 1
        });
        const step2 = createPlatform(player.x + 540, world.groundY - 60, 46, 14);
        step2.tint = "#c54b4b";
        platforms.push(step2);
        const upper2 = createPlatform(player.x + 610, mainRowY, 4 * 36, 14);
        platforms.push(upper2);
        state.levelOneBillTriggerX2 = upper2.x + upper2.w + 40;
        obstacles.push({
          x: upper2.x + upper2.w - 34,
          y: upper2.y - 30,
          w: 34,
          h: 30,
          type: "roach",
          speed: 80,
          vx: -1,
          phase: Math.random() * Math.PI * 2,
          hp: 1
        });
        const step3 = createPlatform(player.x + 860, world.groundY - 60, 46, 14);
        step3.tint = "#c54b4b";
        platforms.push(step3);
        const upper3 = createPlatform(player.x + 930, mainRowY, 4 * 36, 14);
        platforms.push(upper3);
        obstacles.push({
          x: upper3.x + upper3.w - 34,
          y: upper3.y - 30,
          w: 34,
          h: 30,
          type: "roach",
          speed: 70,
          vx: -1,
          phase: Math.random() * Math.PI * 2,
          hp: 1
        });
        const star1 = createPlatform(player.x + 1240, mainRowY, 60, 14);
        star1.isQuestion = true;
        star1.hasStar = true;
        star1.tint = "#2faa59";
        platforms.push(star1);
        addAccessSteps(star1);
        const star2 = createPlatform(player.x + 1480, mainRowY, 60, 14);
        star2.isQuestion = true;
        star2.hasStar = true;
        star2.tint = "#2faa59";
        platforms.push(star2);
        addAccessSteps(star2);
        const star3 = createPlatform(player.x + 1720, mainRowY, 60, 14);
        star3.isQuestion = true;
        star3.hasStar = true;
        star3.tint = "#2faa59";
        platforms.push(star3);
        addAccessSteps(star3);
        seedLevelOneTraps();

        const extraPlatforms = [
          createPlatform(player.x + 2100, mainRowY, 140, 14),
          createPlatform(player.x + 2380, mainRowY, 160, 14),
          createPlatform(player.x + 2680, mainRowY, 140, 14)
        ];
        for (const plat of extraPlatforms) {
          platforms.push(plat);
          addAccessSteps(plat);
          obstacles.push({
            x: plat.x + plat.w - 36,
            y: plat.y - 30,
            w: 34,
            h: 30,
            type: "roach",
            speed: 70,
            vx: -1,
            phase: Math.random() * Math.PI * 2,
            hp: 1
          });
        }
      }
      seedStartPlant();
      if (state.level !== 1) {
        spawnStarPack();
        for (let i = 0; i < 3; i += 1) {
          spawnObstacle();
        }
        for (let i = 0; i < 3; i += 1) {
          spawnObstacle();
        }
      }

      if (hasUserInteracted) {
        speakYeah();
        state.spokenStart = true;
      }
    }

    function die() {
      state.running = false;
      state.dead = true;
      const meterValue = Math.max(0, Math.min(100, state.meter));
      let reasonText = "You got caught.";
      if (state.deathCause === "meter") {
        reasonText = "Addiction meter drained.";
      } else if (state.deathCause === "win") {
        reasonText = `Level ${state.level} complete.`;
      } else if (state.deathDetail) {
        reasonText = `Killed by ${state.deathDetail}.`;
      }
      deathReason.textContent = `${reasonText} Meter: ${Math.round(meterValue)}%`;
      if (state.deathCause === "win") {
        restartBtn.textContent = state.level === levelConfigs.length ? "New Game" : "Next Level";
      } else {
        restartBtn.textContent = "New Game";
      }
      overlay.classList.remove("hidden");
      document.body.classList.add("is-dead");
      if (state.deathCause !== "win") {
        speakDeath();
      }
    }

    function winLevel() {
      state.deathCause = "win";
      die();
    }

    function queueJump() {
      input.jumpQueued = true;
    }

    function queueFire() {
      input.fireQueued = true;
    }

    function queueBelt() {
      input.beltQueued = true;
    }

    function selectVoice() {
      const voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
      if (!voices.length) return null;
      if (cachedVoice && voices.includes(cachedVoice)) {
        return cachedVoice;
      }
      const match = voices.find((voice) =>
        voice.name && voice.name.toLowerCase().includes(voicePreference.name.toLowerCase())
      );
      cachedVoice = match || null;
      return cachedVoice;
    }

    if ("speechSynthesis" in window) {
      window.speechSynthesis.onvoiceschanged = () => {
        selectVoice();
      };
    }

    function speakYeah() {
      if (!state.voiceEnabled) return;
      if (!("speechSynthesis" in window)) return;
      const utter = new SpeechSynthesisUtterance("yeah, yeah");
      const voice = selectVoice();
      if (voice) utter.voice = voice;
      utter.rate = 1.05;
      utter.pitch = 1.1;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utter);
    }

    function speakGreenThing() {
      if (!state.voiceEnabled) return;
      if (!("speechSynthesis" in window)) return;
      const utter = new SpeechSynthesisUtterance("Green Thing");
      const voice = selectVoice();
      if (voice) utter.voice = voice;
      utter.rate = 1.0;
      utter.pitch = 1.0;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utter);
    }

    function speakDeath() {
      if (!state.voiceEnabled) return;
      if (!("speechSynthesis" in window)) return;
      const utter = new SpeechSynthesisUtterance("They on my ass chat");
      const voice = selectVoice();
      if (voice) utter.voice = voice;
      utter.rate = 1.0;
      utter.pitch = 1.0;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utter);
    }

    function handleJump() {
      if (state.dead || !state.running) {
        resetGame();
        return;
      }
      if (player.jumpsLeft > 0) {
        player.vy = -state.jumpPower;
        player.jumpsLeft -= 1;
        if (state.kidAlive) {
          state.kidBurstTimer = 0.5;
          state.kidBurstCount = 3;
        }
      }
    }

    function shootFireball() {
      if (state.dead || !state.running) return;
      const dir = player.facing || 1;
      fireballs.push({
        x: player.x + player.w * 0.6,
        y: player.y + player.h * 0.4,
        r: 8,
        vx: dir * 520,
        vy: 0,
        life: 2.2,
        type: "fireball"
      });
      state.fireMessageTimer = 0.6;
    }

    function releaseBurst() {
      if (state.dead || !state.running) return;
      if (state.burstCharges <= 0) return;
      const baseX = player.x + player.w * 0.6;
      const baseY = player.y + player.h * 0.4;
      const angles = [-Math.PI / 2, -Math.PI / 6, -Math.PI / 3, Math.PI / 6, Math.PI / 3, Math.PI / 2];
      const speed = 380;
      angles.forEach((angle) => {
        fireballs.push({
          x: baseX,
          y: baseY,
          r: 9,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1.4,
          type: "burst"
        });
      });
      state.burstCharges = Math.max(0, state.burstCharges - 1);
    }

    function swingBelt() {
      if (state.dead || !state.running) return;
      state.beltTimer = 0.25;
      const dir = player.facing || 1;
      const hitbox = {
        x: player.x + (dir > 0 ? player.w : -40),
        y: player.y + 10,
        w: 40,
        h: player.h - 20
      };

      for (let i = obstacles.length - 1; i >= 0; i -= 1) {
        if (rectsOverlap(hitbox, obstacles[i])) {
          obstacles.splice(i, 1);
          state.score += 6;
        }
      }

      if (state.billManActive && state.billManHp > 0) {
        const bossBox = {
          x: state.billManX - state.billManW * 0.5,
          y: state.billManY,
          w: state.billManW,
          h: state.billManH
        };
        if (rectsOverlap(hitbox, bossBox)) {
          state.billManHp = Math.max(0, state.billManHp - 2);
          if (state.billManHp <= 0) {
            state.billManActive = false;
            if (state.billManStage === 1) {
              state.billManStage = 2;
            } else if (state.billManStage === 3) {
              state.billManStage = 4;
            }
          }
        }
      }
    }

    function spawnObstacle() {
      const roll = Math.random();
      const isHousing = state.level >= 2 ? roll < 0.3 : roll < 0.2;
      const isHeli = state.level === 2 && !isHousing && roll < 0.55;
      const isBird = state.level >= 3 && !isHousing && roll < 0.7;
      const size = isHeli ? 38 : isBird ? 32 : isHousing ? 46 : 28 + Math.random() * 10;
      const width = isHousing ? size * 0.9 : size * 1.2;
      const spawnX = Math.max(
        state.cameraX + world.width + 180,
        state.lastObstacleX + 280 + Math.random() * 240
      );
      const onPlatformChance = state.level === 1 ? 0.6 : 0.55;
      const onPlatform = !isHousing && platforms.length && Math.random() < onPlatformChance;
      let y = world.groundY - size;
      let patrolPlat = null;
      if (isHeli || isBird) {
        y = world.groundY - 220 - Math.random() * 140;
      } else if (onPlatform) {
        const plat = platforms[Math.floor(Math.random() * platforms.length)];
        y = plat.y - size;
        patrolPlat = plat;
      }
      const obstacle = {
        x: spawnX,
        y,
        w: width,
        h: size,
        type: isHeli ? "heli" : isBird ? "bird" : isHousing ? "housing" : "roach",
        speed: (isHeli ? 120 : isBird ? 140 : isHousing ? 70 : 90) + state.distance * 0.03 + Math.random() * 35,
        vx: -1,
        phase: Math.random() * Math.PI * 2,
        hp: isHeli ? 2 + Math.floor(Math.random() * 2) : 1,
        housingShooter: isHousing ? Math.random() < 0.5 : false,
        housingNextShot: isHousing ? state.time + 1 + Math.random() * 2 : 0,
        housingBurstRemaining: 0,
        housingBurstTimer: 0
      };
      if (!isHeli && !isBird && !isHousing && onPlatform && patrolPlat) {
        obstacle.patrolMinX = patrolPlat.x;
        obstacle.patrolMaxX = Math.max(patrolPlat.x, patrolPlat.x + patrolPlat.w - width);
        obstacle.patrolDir = Math.random() < 0.5 ? -1 : 1;
        obstacle.speed = 60 + Math.random() * 30;
        obstacle.x = patrolPlat.x + (patrolPlat.w - width) * (0.2 + Math.random() * 0.6);
        obstacle.y = patrolPlat.y - size;
        obstacle.nextShot = state.time + 1 + Math.random();
      }
      obstacles.push(obstacle);
      state.lastObstacleX = spawnX;
    }

    function createPlatform(x, y, w, h) {
      const isQuestion = false;
      return {
        x,
        y,
        w,
        h,
        isQuestion,
        used: false,
        hasStar: false,
        tint: "#c54b4b"
      };
    }

    function addAccessSteps(plat) {
      const stepRise = 20;
      const stepWidth = 48;
      const rise = world.groundY - 16 - plat.y;
      if (rise <= stepRise) return;
      const stepCount = Math.min(6, Math.ceil(rise / stepRise));
      for (let i = 1; i <= stepCount; i += 1) {
        const step = createPlatform(
          plat.x - i * (stepWidth + 6),
          Math.min(world.groundY - 120, plat.y + i * stepRise),
          stepWidth,
          12
        );
        step.tint = "#c54b4b";
        platforms.push(step);
        state.lastPlatformX = Math.max(state.lastPlatformX, step.x + step.w);
        state.lastPlatformY = step.y;
      }
    }

    function spawnCollectible() {
      const r = 10;
      const spawnX = Math.max(
        state.cameraX + world.width + 160,
        state.lastCollectibleX + 280 + Math.random() * 240
      );
      if (state.level === 1 && player.x < state.levelEndX * 0.2) return;
      if (state.level === 1) {
        const usePlatform = platforms.length && Math.random() < 0.45;
        let y = world.groundY - 46;
        if (usePlatform) {
          const plat = platforms[Math.floor(Math.random() * platforms.length)];
          y = plat.y - 24;
        }
        collectibles.push({ x: spawnX, y, r });
        state.lastCollectibleX = spawnX;
        return;
      }
      const rowY = world.groundY - 140;
      const usePlatform = platforms.length && Math.random() < 0.6;
      let y = world.groundY - 46;
      if (usePlatform) {
        const plat = platforms[Math.floor(Math.random() * platforms.length)];
        y = plat.y - 24;
      } else {
        y = rowY - 24;
      }
      collectibles.push({
        x: spawnX,
        y,
        r
      });
      state.lastCollectibleX = spawnX;
    }

    function spawnPlatform() {
      const w = 140 + Math.random() * 140;
      const h = 14;
      const rowY = world.groundY - 140;
      let y = rowY;
      const spawnX = Math.max(
        state.cameraX + world.width + 160,
        state.lastPlatformX + 240 + Math.random() * 220
      );
      const plat = createPlatform(spawnX, y, w, h);
      platforms.push(plat);
      state.lastPlatformX = spawnX;
      state.lastPlatformY = y;
      addAccessSteps(plat);
      if (Math.random() < 0.5) {
        const obsW = 34;
        const obsH = 30;
        const obstacle = {
          x: plat.x + (plat.w - obsW) * (0.2 + Math.random() * 0.6),
          y: plat.y - obsH,
          w: obsW,
          h: obsH,
          type: "roach",
          speed: 60 + Math.random() * 30,
          vx: -1,
          phase: Math.random() * Math.PI * 2,
          hp: 1,
          patrolMinX: plat.x,
          patrolMaxX: Math.max(plat.x, plat.x + plat.w - obsW),
          patrolDir: Math.random() < 0.5 ? -1 : 1,
          nextShot: state.time + 1 + Math.random()
        };
        obstacles.push(obstacle);
      }
    }

    function spawnLowPlatformChain() {
      const baseX = Math.max(
        state.cameraX + world.width + 120,
        state.lastPlatformX + 140
      );
      const y = world.groundY - 140;
      const widths = [140, 160, 180];
      for (let i = 0; i < 2; i += 1) {
        const w = widths[Math.floor(Math.random() * widths.length)];
        const x = baseX + i * (w + 90);
        const plat = createPlatform(x, y, w, 14);
        platforms.push(plat);
        addAccessSteps(plat);
        state.lastPlatformX = Math.max(state.lastPlatformX, x + w);
      }
      state.lastPlatformY = y;
    }

    function spawnStairChoice(atX) {
      const yLow = world.groundY - 80;
      const topY = world.groundY - 140;
      const stepRise = 20;
      const stepWidth = 48;
      for (let i = 0; i < 5; i += 1) {
        const stepY = Math.max(topY, yLow - i * stepRise);
        const plat = createPlatform(atX + i * (stepWidth + 6), stepY, stepWidth, 12);
        platforms.push(plat);
        state.lastPlatformX = Math.max(state.lastPlatformX, plat.x + plat.w);
        state.lastPlatformY = plat.y;
      }
    }

    function seedPlatformsForLevel(level) {
      const count = level === 3 ? 10 : 8;
      for (let i = 0; i < count; i += 1) {
        spawnPlatform();
      }
      for (let i = 0; i < 2; i += 1) {
        spawnLowPlatformChain();
      }
    }


    function seedStartPlant() {
      if (state.plantsSpawned >= 3) return;
      plants.push({
        x: player.x + 160,
        y: world.groundY - 60,
        r: 14
      });
      state.plantsSpawned += 1;
    }

    function seedLevelOneTraps() {
      state.levelOneTraps = [
        { x: player.x + 1320, w: 50, h: 48, upTime: 1.6, downTime: 1.6, offset: Math.random() * 2 },
        { x: player.x + 2040, w: 50, h: 48, upTime: 1.8, downTime: 1.6, offset: Math.random() * 2 }
      ];
    }

    function spawnPlant() {
      if (state.level === 1) return;
      if (state.plantsSpawned >= 3) return;
      const spawnX = Math.max(
        state.cameraX + world.width + 220,
        state.lastCollectibleX + 320 + Math.random() * 260
      );
      const nearby = platforms.filter((plat) =>
        Math.abs(plat.x + plat.w * 0.5 - spawnX) < 180
      );
      let targetPlat = nearby.length
        ? nearby[Math.floor(Math.random() * nearby.length)]
        : null;
      if (!targetPlat) {
        const y = world.groundY - 140;
        targetPlat = createPlatform(spawnX - 40, y, 120, 14);
        platforms.push(targetPlat);
        state.lastPlatformX = Math.max(state.lastPlatformX, targetPlat.x + targetPlat.w);
        state.lastPlatformY = y;
      }
      plants.push({
        x: targetPlat.x + targetPlat.w * 0.5,
        y: targetPlat.y - 24,
        r: 14
      });
      state.plantsSpawned += 1;
      state.lastCollectibleX = spawnX;
    }

    function spawnStarPack() {
      const spacing = (state.levelEndX - (player.x + 600)) / 4;
      const baseX = player.x + 520;
      const yOptions = [world.groundY - 140];
      for (let i = 0; i < 3; i += 1) {
        const y = yOptions[i % yOptions.length];
        const plat = createPlatform(baseX + i * spacing, y, 110, 14);
        plat.isQuestion = true;
        plat.used = false;
        plat.hasStar = true;
        plat.tint = "#2faa59";
        platforms.push(plat);
        state.lastPlatformX = Math.max(state.lastPlatformX, plat.x + plat.w);
        addAccessSteps(plat);
        if (y < world.groundY - 240) {
          const stepPlat = createPlatform(plat.x - 120, y + 120, 90, 14);
          platforms.push(stepPlat);
          state.lastPlatformX = Math.max(state.lastPlatformX, stepPlat.x + stepPlat.w);
          state.lastPlatformY = stepPlat.y;
        }
      }
    }

    function maybeDropStar(x, y) {
      if (state.starsSpawned >= 3) return;
      if (Math.random() < 0.15) {
        spawnStar(x, y);
      }
    }

    function spawnStar(x, y) {
      if (state.starsSpawned >= 3) return;
      stars.push({ x, y, r: 12 });
      state.starsSpawned += 1;
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function getDuckableShotY() {
      const standTop = player.y - (player.standH - player.h);
      return standTop + player.standH * 0.15;
    }


    function update(dt) {
      if (!state.running) return;

      state.time += dt;
      const moveDir = (input.right ? 1 : 0) - (input.left ? 1 : 0);
      player.vx = moveDir * state.moveSpeed;
      if (moveDir !== 0) {
        player.facing = moveDir;
      }
      player.x = Math.max(state.cameraX + 40, player.x + player.vx * dt);

      if (player.x > state.distance) {
        state.distance = player.x;
      }
      state.kidX = player.x - 70;
      state.kidDucking = player.ducking;
      state.kidY = world.groundY - (state.kidDucking ? 34 : 48);
      if (state.kidX < state.cameraX + 20) {
        state.kidX = state.cameraX + 20;
      }
      state.score = Math.floor(state.distance * 0.08);
      state.meter = Math.max(0, state.meter - state.meterDrain * dt);
      if (state.meter <= 0) {
        state.deathCause = "meter";
        die();
        return;
      }

      if (state.initialDropTimer > 0) {
        state.initialDropTimer -= dt;
        if (state.initialDropTimer <= 0) {
          const startY = world.groundY - 60;
          collectibles.push(
            { x: player.x + 140, y: startY, r: 10 },
            { x: player.x + 260, y: startY, r: 10 }
          );
          state.lastCollectibleX = player.x + 260;
        }
      }

      state.cameraX = Math.max(state.cameraX, player.x - world.width * 0.3);
      const playerInFrame = player.x + player.w > state.cameraX && player.x < state.cameraX + world.width;
      const kidInFrame = !state.kidAlive || (state.kidX + 28 > state.cameraX && state.kidX < state.cameraX + world.width);
      if (state.copHitCooldown > 0) {
        state.copHitCooldown = Math.max(0, state.copHitCooldown - dt);
      }

      if (state.copCarTimer > 0) {
        state.copCarTimer -= dt;
        if (state.copCarTimer <= 0) {
          state.copCarActive = true;
          state.copCars.push({
            x: state.cameraX + 40,
            y: world.groundY - 36
          });
          state.copCarSpawnTimer = 5;
        }
      }

      if (state.copCarActive && player.x >= state.levelEndX * 0.5) {
        state.copCarActive = false;
        state.copCars.length = 0;
        state.dogsActive = false;
        state.dogs.length = 0;
      }

      if (state.level === 2 && state.billManStage === 0 && player.x >= state.billManMidX - world.width * 0.9) {
        state.billManActive = true;
        state.billManStage = 1;
        state.billManHp = 20;
        state.billManX = state.billManMidX;
        state.billRocketTimer = state.time;
      }
      if (state.level === 1 && state.billManStage === 2 && !state.billManActive && player.x >= state.levelOneBillTriggerX2) {
        state.billManActive = true;
        state.billManStage = 5;
        state.billManHp = 20;
        state.billManX = player.x + world.width * 0.6;
        state.billRocketTimer = state.time;
      }


      if (state.level === 1 && player.x >= state.levelEndX * 0.5) {
        if (state.time - state.levelOneAirTimer >= 2.4 + Math.random() * 1.2) {
          const spawnX = Math.max(
            state.cameraX + world.width + 160,
            state.lastObstacleX + 260 + Math.random() * 200
          );
          obstacles.push({
            x: spawnX,
            y: world.groundY - 220 - Math.random() * 120,
            w: 32,
            h: 28,
            type: "airroach",
            speed: 70,
            vx: -1,
            phase: Math.random() * Math.PI * 2,
            hp: 1
          });
          state.lastObstacleX = spawnX;
          state.levelOneAirTimer = state.time;
        }
      }


      if (state.level === 1 && state.time - state.levelOneAirBurstTimer >= 10) {
        const spawnX = state.cameraX + world.width + 140;
        obstacles.push({
          x: spawnX,
          y: world.groundY - 260 - Math.random() * 120,
          w: 34,
          h: 28,
          type: "airboss",
          speed: 80,
          vx: -1,
          phase: Math.random() * Math.PI * 2,
          hp: 1,
          burstTimer: state.time + 1.2 + Math.random() * 0.6,
          burstCount: 0
        });
        state.lastObstacleX = spawnX;
        state.levelOneAirBurstTimer = state.time;
      }

      if (state.level === 1 && state.billManStage === 0 && player.x >= state.levelOneBillTriggerX) {
        state.billManActive = true;
        state.billManStage = 1;
        state.billManHp = 6;
        state.billManX = player.x + world.width * 0.6;
        state.billRocketTimer = state.time;
        state.levelOneBillTriggerX = Number.POSITIVE_INFINITY;
      }

      if (state.copCarActive) {
        if (state.copCarSpawnTimer > 0) {
          state.copCarSpawnTimer -= dt;
          if (state.copCarSpawnTimer <= 0) {
            state.copCars.push({
              x: state.cameraX + 40,
              y: world.groundY - 36
            });
            state.copCarSpawnTimer = 5;
          }
        }
        const step = state.moveSpeed * 0.5 * dt;
      const playerAirborne = player.y + player.h < world.groundY - 2;
      for (let i = state.copCars.length - 1; i >= 0; i -= 1) {
        const car = state.copCars[i];
        const targetX = player.x - 120 - i * 70;
        if (playerAirborne) {
          car.x += step;
        } else if (targetX > car.x) {
          car.x = Math.min(targetX, car.x + step);
        }
        if (car.x > targetX) {
          car.x = targetX;
        }
      }
    }

      if (state.dogsActive) {
        state.dogsActive = false;
        state.dogs.length = 0;
      }

      if (state.level === 2 && state.copBossActive && state.copBossHp > 0) {
        const targetDir = player.x > state.copBossX ? 1 : -1;
        state.copBossX += targetDir * 80 * dt;
        state.copBossY = world.groundY - 88 - state.copBossJumpOffset;
        if (state.time - state.copBossFireTimer >= 3) {
          const targetDirFire = player.x > state.copBossX ? 1 : -1;
          const targetY = getDuckableShotY();
          enemyShots.push({
            x: state.copBossX,
            y: targetY,
            r: 6,
            vx: targetDirFire * 260,
            life: 3
          });
          state.copBossFireTimer = state.time;
        }
        if (state.time - state.copBossJumpTimer >= 3 + Math.random() * 2) {
          state.copBossJumpTimer = state.time;
          state.copBossJumpOffset = 34;
        }
        if (state.copBossJumpOffset > 0) {
          state.copBossJumpOffset = Math.max(0, state.copBossJumpOffset - 120 * dt);
        }
      }

      if (player.x + player.w >= state.levelEndX) {
        winLevel();
        return;
      }

      const nearEnd = player.x > state.levelEndX * 0.85;
      if (!nearEnd && platforms.length < 14 && state.time - state.lastPlatform > 0.7) {
        spawnPlatform();
        state.lastPlatform = state.time;
      }
      if (!nearEnd && state.time - state.lastPlatform > 1.6 && Math.random() < 0.35) {
        spawnLowPlatformChain();
        state.lastPlatform = state.time;
      }
      if (!nearEnd && state.time - state.lastPlatform > 2.4 && Math.random() < 0.35) {
        spawnStairChoice(state.cameraX + world.width + 220);
        state.lastPlatform = state.time;
      }

      if (state.level === 1 && state.time - state.lastSpawn > 1.0 + Math.random() * 0.6) {
        obstacles.push({
          x: state.cameraX + world.width + 160,
          y: world.groundY - 30,
          w: 34,
          h: 30,
          type: "roach",
          speed: 80 + Math.random() * 20,
          vx: -1,
          phase: Math.random() * Math.PI * 2,
          hp: 1
        });
        if (Math.random() < 0.5) {
          spawnObstacle();
        }
        state.lastSpawn = state.time;
      } else if (state.level !== 1 && state.time - state.lastSpawn > 0.7 + Math.random() * 0.9) {
        spawnObstacle();
        state.lastSpawn = state.time;
      }

      const collectibleInterval = state.level === 1
        ? 3.6 + Math.random() * 2.8
        : 2.2 + Math.random() * 2.0;
      if (state.time - state.lastCollectible > collectibleInterval) {
        spawnCollectible();
        state.lastCollectible = state.time;
      }

      if (state.time - state.lastPlant > 2.6 && Math.random() < 0.7) {
        spawnPlant();
        state.lastPlant = state.time;
      }

      if (state.level === 1 && state.billManStage === 2 && !state.billManActive) {
        state.billManActive = true;
        state.billManStage = 3;
        state.billManHp = 20;
        state.billManX = state.billManEndX;
        state.billRocketTimer = state.time;
      }

      if (state.billManActive) {
        const shouldWait = state.level === 1
          && state.billManStage === 3
          && player.x < state.billManEndX - world.width * 0.6;
        if (shouldWait) {
          state.billManX = state.billManEndX;
        } else {
          const targetDir = player.x > state.billManX ? 1 : -1;
          state.billManX += targetDir * state.billMoveSpeed * dt;
          state.billManY = world.groundY - state.billManH - state.billJumpOffset;

          if (state.time - state.billRocketTimer >= state.billFireRate) {
            const targetY = getDuckableShotY();
            billRockets.push({
              x: state.billManX,
              y: targetY,
              r: 10,
              vx: player.x > state.billManX ? 260 : -260,
              life: 4
            });
            state.billRocketTimer = state.time;
            state.billFollowUpTimer = state.time + state.billFollowUp;
          }
          if (state.billFollowUpTimer > 0 && state.time >= state.billFollowUpTimer) {
            const targetY = getDuckableShotY();
            billFireballs.push({
              x: state.billManX,
              y: targetY,
              r: 7,
              vx: player.x > state.billManX ? 320 : -320,
              life: 3
            });
            state.billFollowUpTimer = 0;
          }

          if (state.time - state.billJumpTimer >= state.billJumpRate) {
            state.billJumpTimer = state.time;
            state.billJumpOffset = 32;
          }
          if (state.billJumpOffset > 0) {
            state.billJumpOffset = Math.max(0, state.billJumpOffset - 120 * dt);
          }
        }
      }

      if (state.level === 2 && state.time - state.enemyShotTimer >= 2.5) {
        const helis = obstacles.filter((obs) => obs.type === "heli");
        if (helis.length) {
          const shooter = helis[Math.floor(Math.random() * helis.length)];
          const targetDir = player.x > shooter.x ? 1 : -1;
          const targetY = getDuckableShotY();
          enemyShots.push({
            x: shooter.x,
            y: targetY,
            r: 6,
            vx: targetDir * 260,
            life: 3
          });
        }
        state.enemyShotTimer = state.time;
      }

      if (state.level === 1 && player.x >= state.levelEndX * 0.5 && state.time - state.enemyShotTimer >= 1.6) {
        const airRoaches = obstacles.filter((obs) => obs.type === "airroach");
        if (airRoaches.length) {
          const shooter = airRoaches[Math.floor(Math.random() * airRoaches.length)];
          enemyShots.push({
            x: shooter.x,
            y: shooter.y + 18,
            r: 6,
            vx: 0,
            vy: 220,
            life: 3
          });
        }
        state.enemyShotTimer = state.time;
      }

      if (state.level >= 3 && state.time - state.enemyShotTimer >= 3.5) {
        const birds = obstacles.filter((obs) => obs.type === "bird");
        if (birds.length) {
          const shooter = birds[Math.floor(Math.random() * birds.length)];
          const targetDir = player.x > shooter.x ? 1 : -1;
          const targetY = getDuckableShotY();
          enemyShots.push({
            x: shooter.x,
            y: targetY,
            r: 5,
            vx: targetDir * 300,
            life: 3
          });
        }
        state.enemyShotTimer = state.time;
      }

      obstacles.forEach((obs) => {
        if (typeof obs.patrolMinX === "number") {
          obs.x += obs.patrolDir * obs.speed * dt;
          if (obs.x <= obs.patrolMinX) {
            obs.x = obs.patrolMinX;
            obs.patrolDir = 1;
          } else if (obs.x >= obs.patrolMaxX) {
            obs.x = obs.patrolMaxX;
            obs.patrolDir = -1;
          }
          if (state.time >= (obs.nextShot || 0)) {
            enemyShots.push({
              x: obs.x + obs.w * 0.5,
              y: obs.y + obs.h + 6,
              r: 6,
              vx: 0,
              vy: 220,
              life: 3
            });
            obs.nextShot = state.time + 1 + Math.random();
          }
        } else {
          const dir = obs.x > player.x ? -1 : 1;
          obs.x += dir * obs.speed * dt;
        }
        if (obs.type === "housing" && obs.housingShooter && playerInFrame && kidInFrame) {
          if (obs.housingBurstRemaining > 0 && state.time >= obs.housingBurstTimer) {
            const targetDir = player.x > obs.x ? 1 : -1;
            const targetY = getDuckableShotY();
            enemyShots.push({
              x: obs.x + obs.w * 0.5,
              y: targetY,
              r: 6,
              vx: targetDir * 260,
              life: 3
            });
            obs.housingBurstRemaining -= 1;
            obs.housingBurstTimer = state.time + 0.28;
            if (obs.housingBurstRemaining <= 0) {
              obs.housingNextShot = state.time + 1 + Math.random() * 3;
            }
          } else if (obs.housingBurstRemaining <= 0 && state.time >= obs.housingNextShot) {
            obs.housingBurstRemaining = 1 + Math.floor(Math.random() * 3);
            obs.housingBurstTimer = state.time;
          }
        }
        if (obs.type === "airboss") {
          obs.y += Math.sin(state.time * 1.6 + obs.phase) * 20 * dt;
          if (state.time >= obs.burstTimer && obs.burstCount < 2) {
            enemyShots.push({
              x: obs.x,
              y: obs.y + 18,
              r: 6,
              vx: 0,
              vy: 240,
              life: 3
            });
            obs.burstCount += 1;
            obs.burstTimer = state.time + 1;
          }
        }
      });

      fireballs.forEach((fireball) => {
        fireball.x += fireball.vx * dt;
        fireball.y += (fireball.vy || 0) * dt;
        fireball.life -= dt;
      });

      enemyShots.forEach((shot) => {
        shot.x += shot.vx * dt;
        shot.y += (shot.vy || 0) * dt;
        shot.life -= dt;
      });

      billRockets.forEach((rocket) => {
        rocket.x += rocket.vx * dt;
        rocket.life -= dt;
      });

      billFireballs.forEach((shot) => {
        shot.x += shot.vx * dt;
        shot.life -= dt;
      });

      const cleanupX = state.cameraX - 200;
      for (let i = platforms.length - 1; i >= 0; i -= 1) {
        if (platforms[i].x + platforms[i].w < cleanupX) {
          platforms.splice(i, 1);
        }
      }
      for (let i = obstacles.length - 1; i >= 0; i -= 1) {
        if (obstacles[i].x + obstacles[i].w < cleanupX) {
          obstacles.splice(i, 1);
        }
      }
      for (let i = collectibles.length - 1; i >= 0; i -= 1) {
        if (collectibles[i].x + collectibles[i].r < cleanupX) {
          collectibles.splice(i, 1);
        }
      }
      for (let i = plants.length - 1; i >= 0; i -= 1) {
        if (plants[i].x + plants[i].r < cleanupX) {
          plants.splice(i, 1);
        }
      }
      for (let i = fireballs.length - 1; i >= 0; i -= 1) {
        if (fireballs[i].life <= 0 || fireballs[i].x < cleanupX || fireballs[i].x > state.cameraX + world.width + 200) {
          fireballs.splice(i, 1);
        }
      }
      for (let i = enemyShots.length - 1; i >= 0; i -= 1) {
        if (enemyShots[i].life <= 0 || enemyShots[i].x < cleanupX || enemyShots[i].y > world.height + 120) {
          enemyShots.splice(i, 1);
        }
      }
      for (let i = billRockets.length - 1; i >= 0; i -= 1) {
        if (billRockets[i].life <= 0 || billRockets[i].x < cleanupX || billRockets[i].x > state.cameraX + world.width + 200) {
          billRockets.splice(i, 1);
        }
      }
      for (let i = billFireballs.length - 1; i >= 0; i -= 1) {
        if (billFireballs[i].life <= 0 || billFireballs[i].x < cleanupX || billFireballs[i].x > state.cameraX + world.width + 200) {
          billFireballs.splice(i, 1);
        }
      }

      const prevY = player.y;
      const wasDucking = player.ducking;
      if (input.down && player.vy === 0) {
        player.ducking = true;
      } else {
        player.ducking = false;
      }
      if (player.ducking && !wasDucking) {
        const newH = player.standH * 0.6;
        player.y += player.h - newH;
        player.h = newH;
      } else if (!player.ducking && wasDucking) {
        const newH = player.standH;
        player.y -= newH - player.h;
        player.h = newH;
      }
      player.vy += state.gravity * dt;
      player.y += player.vy * dt;

      let landed = false;
      for (const plat of platforms) {
        const wasAbove = prevY + player.h <= plat.y + 2;
        const isFalling = player.vy >= 0;
        const withinX = player.x + player.w > plat.x && player.x < plat.x + plat.w;
        if (wasAbove && isFalling && withinX) {
          if (player.y + player.h >= plat.y) {
            player.y = plat.y - player.h;
            player.vy = 0;
            landed = true;
            break;
          }
        }
      }

      if (!landed && player.y + player.h >= world.groundY) {
        player.y = world.groundY - player.h;
        player.vy = 0;
        landed = true;
      }

      for (const plat of platforms) {
        const wasBelow = prevY >= plat.y + plat.h - 2;
        const isRising = player.vy < 0;
        const withinX = player.x + player.w > plat.x && player.x < plat.x + plat.w;
        if (wasBelow && isRising && withinX) {
          if (player.y <= plat.y + plat.h) {
            player.y = plat.y + plat.h;
            player.vy = 0;
            if (plat.isQuestion && !plat.used) {
              plat.used = true;
              if (plat.hasStar && plat.spawnsPlant) {
                plants.push({
                  x: plat.x + plat.w * 0.5,
                  y: plat.y - 20,
                  r: 12,
                  vy: -280
                });
              } else if (plat.hasStar) {
                spawnStar(plat.x + plat.w * 0.5, plat.y - 24);
              }
            }
          }
        }
      }

      if (landed) {
        player.jumpsLeft = 1;
      }

      const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
      if (state.copBossActive && state.copBossHp > 0) {
        const bossBox = {
          x: state.copBossX - 30,
          y: state.copBossY,
          w: 60,
          h: 88
        };
        if (rectsOverlap(playerBox, bossBox)) {
          state.deathCause = "enemy";
          state.deathDetail = "Cop boss";
          die();
          return;
        }
      }
      if (state.copCarActive) {
        for (const car of state.copCars) {
          const carBox = {
            x: car.x,
            y: car.y,
            w: 90,
            h: 30
          };
          if (rectsOverlap(playerBox, carBox)) {
            state.deathCause = "enemy";
            state.deathDetail = "Cop car";
            die();
            return;
          }
        }
      }

      const kidBox = {
        x: state.kidX,
        y: state.kidY,
        w: 28,
        h: state.kidDucking ? 34 : 48
      };
      if (state.billManActive && state.billManHp > 0) {
        const bossBox = {
          x: state.billManX - state.billManW * 0.5,
          y: state.billManY,
          w: state.billManW,
          h: state.billManH
        };
        if (rectsOverlap(playerBox, bossBox)) {
          if (state.invincibleTimer > 0) {
            state.billManHp = 0;
            state.billManActive = false;
            if (state.billManStage === 1) {
              state.billManStage = 2;
            } else if (state.billManStage === 3) {
              state.billManStage = 4;
            }
          } else {
            state.deathCause = "enemy";
            state.deathDetail = "Bill man";
            die();
            return;
          }
        }
      }
      for (let i = obstacles.length - 1; i >= 0; i -= 1) {
        const obs = obstacles[i];
        if (rectsOverlap(playerBox, obs)) {
          const playerFeet = player.y + player.h;
          const stompZone = obs.y + obs.h * 0.35;
          if (state.invincibleTimer > 0) {
            maybeDropStar(obs.x + obs.w * 0.5, obs.y - 20);
            obstacles.splice(i, 1);
            state.score += 6;
          } else if (player.vy > 0 && playerFeet <= stompZone) {
            obstacles.splice(i, 1);
            player.vy = -state.jumpPower * 0.45;
            state.score += 10;
            maybeDropStar(obs.x + obs.w * 0.5, obs.y - 20);
          } else {
            state.deathCause = "enemy";
            die();
            break;
          }
        }
        if (state.kidAlive && rectsOverlap(kidBox, obs)) {
          state.kidHits += 1;
          if (state.kidHits >= 3) {
            state.kidAlive = false;
          }
        }
      }

      for (let i = enemyShots.length - 1; i >= 0; i -= 1) {
        const shot = enemyShots[i];
        if (player.ducking && shot.y < player.y + player.h * 0.25) {
          continue;
        }
        const dx = player.x + player.w * 0.5 - shot.x;
        const dy = player.y + player.h * 0.5 - shot.y;
        if (Math.hypot(dx, dy) < player.w * 0.4 + shot.r) {
          enemyShots.splice(i, 1);
          if (state.invincibleTimer > 0) {
            break;
          } else {
            state.deathCause = "enemy";
            state.deathDetail = "Fireball";
            die();
            break;
          }
        }
        if (state.kidAlive && Math.hypot(kidBox.x + 14 - shot.x, kidBox.y + 24 - shot.y) < 20 + shot.r) {
          enemyShots.splice(i, 1);
          state.kidHits += 1;
          if (state.kidHits >= 3) {
            state.kidAlive = false;
          }
        }
      }

      for (let i = billRockets.length - 1; i >= 0; i -= 1) {
        const rocket = billRockets[i];
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          if (Math.hypot(rocket.x - fb.x, rocket.y - fb.y) < rocket.r + fb.r + 4) {
            billRockets.splice(i, 1);
            fireballs.splice(j, 1);
            break;
          }
        }
      }

      for (let i = billFireballs.length - 1; i >= 0; i -= 1) {
        const shot = billFireballs[i];
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          if (Math.hypot(shot.x - fb.x, shot.y - fb.y) < shot.r + fb.r + 4) {
            billFireballs.splice(i, 1);
            fireballs.splice(j, 1);
            break;
          }
        }
      }
      for (let i = billRockets.length - 1; i >= 0; i -= 1) {
        const shot = billRockets[i];
        const dx = player.x + player.w * 0.5 - shot.x;
        const dy = player.y + player.h * 0.5 - shot.y;
        if (Math.hypot(dx, dy) < player.w * 0.4 + shot.r) {
          billRockets.splice(i, 1);
          if (state.invincibleTimer > 0) {
            break;
          } else {
            state.deathCause = "enemy";
            state.deathDetail = "Rocket";
            die();
            break;
          }
        }
        if (state.kidAlive && Math.hypot(kidBox.x + 14 - shot.x, kidBox.y + 24 - shot.y) < 20 + shot.r) {
          billRockets.splice(i, 1);
          state.kidHits += 1;
          if (state.kidHits >= 3) {
            state.kidAlive = false;
          }
        }
      }

      for (let i = billFireballs.length - 1; i >= 0; i -= 1) {
        const shot = billFireballs[i];
        if (player.ducking && shot.y < player.y + player.h * 0.25) {
          continue;
        }
        const dx = player.x + player.w * 0.5 - shot.x;
        const dy = player.y + player.h * 0.5 - shot.y;
        if (Math.hypot(dx, dy) < player.w * 0.4 + shot.r) {
          billFireballs.splice(i, 1);
          if (state.invincibleTimer > 0) {
            break;
          } else {
            state.deathCause = "enemy";
            state.deathDetail = "Bill fireball";
            die();
            break;
          }
        }
        if (state.kidAlive && Math.hypot(kidBox.x + 14 - shot.x, kidBox.y + 24 - shot.y) < 20 + shot.r) {
          billFireballs.splice(i, 1);
          state.kidHits += 1;
          if (state.kidHits >= 3) {
            state.kidAlive = false;
          }
        }
      }

      for (let i = obstacles.length - 1; i >= 0; i -= 1) {
        const obs = obstacles[i];
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          const dx = obs.x + obs.w * 0.5 - fb.x;
          const dy = obs.y + obs.h * 0.5 - fb.y;
          if (Math.hypot(dx, dy) < obs.w * 0.6 + fb.r) {
            fireballs.splice(j, 1);
            obs.hp -= 1;
            if (obs.hp <= 0) {
              if (Math.random() < 0.2) {
                if (state.plantsSpawned < 3) {
                  plants.push({
                    x: obs.x + obs.w * 0.5,
                    y: obs.y - 8,
                    r: 12
                  });
                  state.plantsSpawned += 1;
                }
              }
              maybeDropStar(obs.x + obs.w * 0.5, obs.y - 20);
              obstacles.splice(i, 1);
              state.score += 8;
            }
            break;
          }
        }
      }

      if (state.billManActive && state.billManHp > 0) {
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          const bossCenterX = state.billManX;
          const bossCenterY = state.billManY + state.billManH * 0.5;
          const dx = bossCenterX - fb.x;
          const dy = bossCenterY - fb.y;
          if (Math.hypot(dx, dy) < 38 + fb.r) {
            fireballs.splice(j, 1);
            state.billManHp -= 1;
            if (state.billManHp <= 0) {
              state.billManActive = false;
              if (state.billManStage === 1) {
                state.billManStage = 2;
              } else if (state.billManStage === 3) {
                state.billManStage = 4;
              } else if (state.billManStage === 5) {
                state.billManStage = 6;
                spawnStar(state.billManX, state.billManY - 24);
              }
              if (state.billManStage !== 6) {
                maybeDropStar(state.billManX, state.billManY - 20);
              }
              break;
            }
          }
        }
      }

      if (state.copBossActive && state.copBossHp > 0) {
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          const dx = state.copBossX - fb.x;
          const dy = (state.copBossY + 40) - fb.y;
          if (Math.hypot(dx, dy) < 34 + fb.r) {
            fireballs.splice(j, 1);
            state.copBossHp -= 1;
            if (state.copBossHp <= 0) {
              state.copBossActive = false;
              maybeDropStar(state.copBossX, state.copBossY - 20);
            }
          }
        }
      }

      for (let i = collectibles.length - 1; i >= 0; i -= 1) {
        const item = collectibles[i];
        const dx = player.x + player.w / 2 - item.x;
        const dy = player.y + player.h / 2 - item.y;
        const dist = Math.hypot(dx, dy);
        if (dist < player.w * 0.6 + item.r) {
          collectibles.splice(i, 1);
          state.score += 15;
          state.meter = Math.min(100, state.meter + state.meterAdd);
          state.collectMessageTimer = 0.6;
          speakYeah();
        }
      }

      for (let i = plants.length - 1; i >= 0; i -= 1) {
        const plant = plants[i];
        if (typeof plant.vy === "number") {
          plant.vy += 900 * dt;
          plant.y += plant.vy * dt;
          const groundY = world.groundY - plant.r * 0.6;
          if (plant.y > groundY) {
            plant.y = groundY;
            plant.vy = 0;
          }
        }
        const dx = player.x + player.w / 2 - plant.x;
        const dy = player.y + player.h / 2 - plant.y;
        const dist = Math.hypot(dx, dy);
        if (dist < player.w * 0.6 + plant.r) {
          plants.splice(i, 1);
          state.meter = 100;
          state.burstCharges = Math.min(3, state.burstCharges + 1);
          speakGreenThing();
        }
      }

      for (let i = stars.length - 1; i >= 0; i -= 1) {
        const star = stars[i];
        const dx = player.x + player.w / 2 - star.x;
        const dy = player.y + player.h / 2 - star.y;
        const dist = Math.hypot(dx, dy);
        if (dist < player.w * 0.6 + star.r) {
          stars.splice(i, 1);
          state.invincibleTimer = 5;
        }
      }
    }

    function drawBackground() {
      ctx.clearRect(0, 0, world.width, world.height);

      const skylineY = world.height * 0.42;
      ctx.fillStyle = "rgba(10, 10, 18, 0.75)";
      ctx.fillRect(0, skylineY, world.width, world.height - skylineY);

      const layers = [
        { count: 8, height: 80, color: "rgba(32, 26, 44, 0.8)", offset: 0.4 },
        { count: 10, height: 120, color: "rgba(24, 22, 36, 0.85)", offset: 0.7 }
      ];

      layers.forEach((layer, index) => {
        const shift = (state.cameraX * 0.08 * (index + 1)) % 200;
        ctx.fillStyle = layer.color;
        for (let i = 0; i < layer.count; i += 1) {
          const width = 90 + (i % 3) * 40;
          const x = i * 140 - shift;
          const y = skylineY - layer.height - (i % 2) * 30;
          ctx.fillRect(x, y, width, layer.height + (i % 2) * 30);
        }
      });

      ctx.fillStyle = "#2c263a";
      ctx.fillRect(0, world.groundY, world.width, world.height - world.groundY);

      ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
      ctx.lineWidth = 2;
      for (let i = 0; i < 12; i += 1) {
        const x = ((state.cameraX * 0.2) % 220) + i * 220;
        ctx.beginPath();
        ctx.moveTo(x, world.groundY + 12);
        ctx.lineTo(x + 80, world.groundY + 12);
        ctx.stroke();
      }
    }

    function drawPlatform(plat) {
      ctx.fillStyle = plat.tint
        ? plat.tint
        : plat.isQuestion && plat.hasStar && !plat.used
          ? "#ffd166"
          : plat.isQuestion && !plat.used
            ? "#f2c94c"
            : "#8b4b2b";
      ctx.fillRect(plat.x, plat.y, plat.w, plat.h);

      ctx.strokeStyle = "rgba(255, 214, 160, 0.35)";
      ctx.lineWidth = 2;
      ctx.strokeRect(plat.x + 1, plat.y + 1, plat.w - 2, plat.h - 2);

      const brickW = 36;
      const brickH = 10;
      const rows = Math.max(1, Math.floor(plat.h / brickH));
      const cols = Math.max(1, Math.floor(plat.w / brickW));

      ctx.strokeStyle = "rgba(60, 26, 14, 0.6)";
      ctx.lineWidth = 1.5;
      for (let row = 0; row < rows; row += 1) {
        const y = plat.y + row * brickH;
        ctx.beginPath();
        ctx.moveTo(plat.x, y);
        ctx.lineTo(plat.x + plat.w, y);
        ctx.stroke();

        const offset = row % 2 === 0 ? 0 : brickW * 0.5;
        for (let col = 0; col <= cols; col += 1) {
          const x = plat.x + col * brickW - offset;
          if (x > plat.x && x < plat.x + plat.w) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + brickH);
            ctx.stroke();
          }
        }
      }
    }


    function drawTrapHouse() {
      const width = 180;
      const height = 140;
      const x = state.levelEndX - width * 0.5 - state.cameraX;
      const y = world.groundY - height;

      ctx.save();
      ctx.fillStyle = "#3a2436";
      ctx.fillRect(x, y, width, height);

      ctx.fillStyle = "#251823";
      ctx.fillRect(x + 18, y + 50, 50, 90);
      ctx.fillStyle = "#1a1016";
      ctx.fillRect(x + 30, y + 72, 12, 26);

      ctx.fillStyle = "#ffb200";
      ctx.fillRect(x + 86, y + 60, 70, 38);
      ctx.strokeStyle = "rgba(0, 0, 0, 0.6)";
      ctx.lineWidth = 2;
      ctx.strokeRect(x + 86, y + 60, 70, 38);

      ctx.fillStyle = "#0f0f14";
      ctx.font = "bold 15px \"Impact\", sans-serif";
      ctx.textAlign = "center";
      const parts = state.goalLabel.split(" ");
      if (parts.length >= 2) {
        ctx.fillText(parts[0], x + width / 2, y + 22);
        ctx.fillText(parts.slice(1).join(" "), x + width / 2, y + 38);
      } else {
        ctx.fillText(state.goalLabel, x + width / 2, y + 28);
      }
      ctx.restore();
    }

    function drawCourier() {
      const screenX = player.x - state.cameraX;
      const y = player.y;
      const w = player.w;
      const h = player.h;

      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#5b3a2a";
      ctx.beginPath();
      ctx.arc(w * 0.55, h * 0.18, w * 0.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#1b1b22";
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.32);
      ctx.lineTo(w * 0.9, h * 0.32);
      ctx.lineTo(w * 0.75, h * 0.95);
      ctx.lineTo(w * 0.25, h * 0.95);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "#2665ff";
      ctx.beginPath();
      ctx.moveTo(w * 0.25, h * 0.45);
      ctx.lineTo(w * 0.8, h * 0.4);
      ctx.lineTo(w * 0.7, h * 0.75);
      ctx.lineTo(w * 0.18, h * 0.8);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "#141018";
      ctx.fillRect(w * 0.08, h * 0.62, w * 0.42, h * 0.22);
      ctx.fillStyle = "#2f2737";
      ctx.fillRect(w * 0.12, h * 0.65, w * 0.34, h * 0.16);

      ctx.strokeStyle = "#ffd166";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.35);
      ctx.lineTo(w * 0.02, h * 0.7);
      ctx.stroke();

      ctx.fillStyle = "#0f0f14";
      ctx.fillRect(w * 0.62, h * 0.16, 6, 6);
      ctx.fillRect(w * 0.42, h * 0.16, 6, 6);

      ctx.strokeStyle = "#ffd166";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(w * 0.55, h * 0.34, w * 0.12, 0, Math.PI);
      ctx.stroke();

      ctx.fillStyle = "#0f0f14";
      ctx.fillRect(w * 0.22, h * 0.88, w * 0.18, h * 0.08);
      ctx.fillRect(w * 0.6, h * 0.88, w * 0.18, h * 0.08);

      const stride = Math.sin(state.time * 10 + player.x * 0.02) * 4;
      ctx.strokeStyle = "#1b1b22";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(w * 0.4, h * 0.78);
      ctx.lineTo(w * 0.38, h * 0.92 + stride);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w * 0.6, h * 0.78);
      ctx.lineTo(w * 0.62, h * 0.92 - stride);
      ctx.stroke();
      ctx.fillStyle = "#f6f1e8";
      ctx.fillRect(w * 0.3, h * 0.92 + stride - 2, w * 0.2, h * 0.06);
      ctx.fillRect(w * 0.5, h * 0.92 - stride - 2, w * 0.2, h * 0.06);

      ctx.restore();
    }

    function drawRoach(obs) {
      const screenX = obs.x - state.cameraX;
      const { y, w, h } = obs;
      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#4a2a1a";
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h * 0.55, w * 0.5, h * 0.45, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2a160c";
      ctx.beginPath();
      ctx.ellipse(w * 0.6, h * 0.45, w * 0.2, h * 0.28, 0.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#8a5a3a";
      ctx.lineWidth = 2;
      const stride = Math.sin(state.time * 8 + obs.phase) * 6;
      for (let i = 0; i < 3; i += 1) {
        const lx = w * 0.2 + i * w * 0.2;
        ctx.beginPath();
        ctx.moveTo(lx, h * 0.5);
        ctx.lineTo(lx - w * 0.15, h * 0.2 + stride);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(lx + w * 0.2, h * 0.55);
        ctx.lineTo(lx + w * 0.35, h * 0.8 - stride);
        ctx.stroke();
      }

      ctx.strokeStyle = "#cfa07a";
      ctx.beginPath();
      ctx.moveTo(w * 0.78, h * 0.25);
      ctx.lineTo(w * 0.95, h * 0.05);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w * 0.82, h * 0.35);
      ctx.lineTo(w * 1.0, h * 0.2);
      ctx.stroke();

      ctx.restore();
    }

    function drawHousingEnemy(obs) {
      const screenX = obs.x - state.cameraX;
      const { y, w, h } = obs;
      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#f1d6c7";
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.18, w * 0.22, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = state.billShirt;
      ctx.fillRect(w * 0.25, h * 0.35, w * 0.5, h * 0.5);

      ctx.fillStyle = "#1a1412";
      ctx.fillRect(w * 0.38, h * 0.85, w * 0.16, h * 0.15);
      ctx.fillRect(w * 0.56, h * 0.85, w * 0.16, h * 0.15);

      ctx.strokeStyle = "#e9dfd2";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.45);
      ctx.lineTo(w * 0.05, h * 0.8);
      ctx.stroke();

      ctx.fillStyle = state.billSign;
      ctx.fillRect(w * 0.6, h * 0.2, w * 0.6, h * 0.4);
      ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
      ctx.lineWidth = 2;
      ctx.strokeRect(w * 0.6, h * 0.2, w * 0.6, h * 0.4);

      ctx.fillStyle = "#0f0f14";
      ctx.font = "bold 8px \"Trebuchet MS\", sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("HOUSING", w * 0.9, h * 0.35);
      ctx.fillText("AUTHORITY", w * 0.9, h * 0.48);

      ctx.restore();
    }

    function drawHelicopter(obs) {
      const screenX = obs.x - state.cameraX;
      const { y, w, h } = obs;
      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#3b3f4d";
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h * 0.6, w * 0.5, h * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#1b1f28";
      ctx.fillRect(w * 0.2, h * 0.35, w * 0.5, h * 0.2);

      ctx.strokeStyle = "#d9d9d9";
      ctx.lineWidth = 3;
      const rotor = Math.sin(state.time * 12 + obs.phase) * 12;
      ctx.beginPath();
      ctx.moveTo(w * 0.5 - 30 - rotor, h * 0.2);
      ctx.lineTo(w * 0.5 + 30 + rotor, h * 0.2);
      ctx.stroke();

      ctx.strokeStyle = "#3b3f4d";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(w * 0.65, h * 0.55);
      ctx.lineTo(w * 0.9, h * 0.7);
      ctx.stroke();

      ctx.restore();
    }

    function drawBird(obs) {
      const screenX = obs.x - state.cameraX;
      const { y, w, h } = obs;
      ctx.save();
      ctx.translate(screenX, y);

      const flap = Math.sin(state.time * 12 + obs.phase) * 6;
      ctx.fillStyle = "#3c3f4a";
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h * 0.55, w * 0.4, h * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#1d2028";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.45);
      ctx.lineTo(w * 0.05, h * 0.25 - flap);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w * 0.8, h * 0.45);
      ctx.lineTo(w * 0.95, h * 0.25 + flap);
      ctx.stroke();

      ctx.fillStyle = "#f2c94c";
      ctx.beginPath();
      ctx.moveTo(w * 0.6, h * 0.6);
      ctx.lineTo(w * 0.9, h * 0.7);
      ctx.lineTo(w * 0.62, h * 0.75);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawBillMan() {
      if (!state.billManActive || state.billManHp <= 0) return;
      const w = state.billManW;
      const h = state.billManH;
      const screenX = state.billManX - state.cameraX;
      const y = state.billManY;

      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#f1d6c7";
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.18, w * 0.22, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2c2b30";
      ctx.fillRect(w * 0.28, h * 0.32, w * 0.44, h * 0.5);

      ctx.fillStyle = "#1a1412";
      ctx.fillRect(w * 0.34, h * 0.82, w * 0.16, h * 0.16);
      ctx.fillRect(w * 0.56, h * 0.82, w * 0.16, h * 0.16);

      ctx.strokeStyle = "#e9dfd2";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.4);
      ctx.lineTo(w * 0.02, h * 0.8);
      ctx.stroke();

      ctx.fillStyle = "#f6f1e8";
      ctx.fillRect(w * 0.58, h * 0.15, w * 0.6, h * 0.38);
      ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
      ctx.lineWidth = 2;
      ctx.strokeRect(w * 0.58, h * 0.15, w * 0.6, h * 0.38);

      ctx.fillStyle = "#0f0f14";
      ctx.font = "bold 8px \"Trebuchet MS\", sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(state.billLabel, w * 0.88, h * 0.35);

      ctx.restore();
    }

    function drawCopCar() {
      if (!state.copCarActive) return;
      ctx.save();
      for (const car of state.copCars) {
        const screenX = car.x - state.cameraX;
        const y = car.y;
        ctx.translate(screenX, y);

        ctx.fillStyle = "#1f2a44";
        ctx.fillRect(0, 8, 90, 22);
        ctx.fillStyle = "#2c3a5a";
        ctx.fillRect(10, 0, 40, 16);
        ctx.fillStyle = "#ff5a4f";
        ctx.fillRect(52, 2, 12, 6);
        ctx.fillStyle = "#4ad9d9";
        ctx.fillRect(66, 2, 12, 6);

        ctx.fillStyle = "#0f0f14";
        ctx.beginPath();
        ctx.arc(18, 30, 8, 0, Math.PI * 2);
        ctx.arc(72, 30, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      ctx.restore();
    }

    function drawDogs() {
      if (!state.dogsActive) return;
      ctx.save();
      for (const dog of state.dogs) {
        const screenX = state.dogsX + dog.offset - state.cameraX;
        const y = dog.y;
        ctx.translate(screenX, y);
        ctx.fillStyle = "#6b4b35";
        ctx.fillRect(0, 8, 24, 12);
        ctx.fillStyle = "#3b2a1f";
        ctx.fillRect(14, 4, 10, 8);
        ctx.fillStyle = "#0f0f14";
        ctx.fillRect(4, 18, 6, 4);
        ctx.fillRect(14, 18, 6, 4);
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      ctx.restore();
    }

    function drawCopBoss() {
      if (!state.copBossActive || state.copBossHp <= 0) return;
      const screenX = state.copBossX - state.cameraX;
      const y = state.copBossY;
      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#f1d6c7";
      ctx.beginPath();
      ctx.arc(30, 16, 12, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#1f2a44";
      ctx.fillRect(12, 28, 36, 42);
      ctx.fillStyle = "#ff5a4f";
      ctx.fillRect(18, 38, 24, 10);

      ctx.fillStyle = "#0f0f14";
      ctx.fillRect(16, 70, 12, 14);
      ctx.fillRect(36, 70, 12, 14);

      ctx.restore();
    }

    function drawKid() {
      if (!state.kidAlive) return;
      const screenX = state.kidX - state.cameraX;
      const y = state.kidY;
      const w = 28;
      const h = state.kidDucking ? 34 : 48;

      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#c68f62";
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.2, w * 0.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#1f1a28";
      ctx.fillRect(w * 0.22, h * 0.35, w * 0.56, h * 0.5);

      ctx.strokeStyle = "#111018";
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i += 1) {
        const x = w * 0.28 + i * 4;
        ctx.beginPath();
        ctx.moveTo(x, h * 0.06);
        ctx.lineTo(x, h * 0.18);
        ctx.stroke();
      }

      ctx.fillStyle = "#0f0f14";
      ctx.fillRect(w * 0.28, h * 0.82, w * 0.16, h * 0.14);
      ctx.fillRect(w * 0.56, h * 0.82, w * 0.16, h * 0.14);

      const kidStride = Math.sin(state.time * 10 + state.kidX * 0.03) * 3;
      ctx.strokeStyle = "#1b1b22";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(w * 0.38, h * 0.7);
      ctx.lineTo(w * 0.36, h * 0.88 + kidStride);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w * 0.62, h * 0.7);
      ctx.lineTo(w * 0.64, h * 0.88 - kidStride);
      ctx.stroke();
      ctx.fillStyle = "#f6f1e8";
      ctx.fillRect(w * 0.28, h * 0.88 + kidStride - 2, w * 0.2, h * 0.06);
      ctx.fillRect(w * 0.52, h * 0.88 - kidStride - 2, w * 0.2, h * 0.06);

      ctx.restore();
    }

    function drawCigarettes(item) {
      const screenX = item.x - state.cameraX;
      ctx.save();
      ctx.translate(screenX, item.y);
      const w = item.r * 2.8;
      const h = item.r * 0.9;

      ctx.fillStyle = "#f2efe6";
      ctx.beginPath();
      ctx.roundRect(-w / 2, -h / 2, w, h, 6);
      ctx.fill();

      ctx.fillStyle = "#d28a6a";
      ctx.fillRect(w * 0.2, -h / 2, w * 0.2, h);

      ctx.fillStyle = "#2a1d1d";
      ctx.fillRect(-w / 2, -h / 2, w * 0.08, h);

      ctx.strokeStyle = "rgba(255, 178, 0, 0.7)";
      ctx.lineWidth = 2;
      ctx.strokeRect(-w / 2, -h / 2, w, h);

      ctx.restore();
    }

    function drawPlant(plant) {
      const screenX = plant.x - state.cameraX;
      ctx.save();
      ctx.translate(screenX, plant.y);

      ctx.fillStyle = "#2fa84a";
      ctx.beginPath();
      ctx.moveTo(0, -plant.r * 1.1);
      ctx.lineTo(plant.r * 0.15, -plant.r * 0.4);
      ctx.lineTo(plant.r * 0.8, -plant.r * 0.9);
      ctx.lineTo(plant.r * 0.35, -plant.r * 0.1);
      ctx.lineTo(plant.r * 1.1, plant.r * 0.2);
      ctx.lineTo(plant.r * 0.3, plant.r * 0.15);
      ctx.lineTo(plant.r * 0.75, plant.r * 0.95);
      ctx.lineTo(0, plant.r * 0.35);
      ctx.lineTo(-plant.r * 0.75, plant.r * 0.95);
      ctx.lineTo(-plant.r * 0.3, plant.r * 0.15);
      ctx.lineTo(-plant.r * 1.1, plant.r * 0.2);
      ctx.lineTo(-plant.r * 0.35, -plant.r * 0.1);
      ctx.lineTo(-plant.r * 0.8, -plant.r * 0.9);
      ctx.lineTo(-plant.r * 0.15, -plant.r * 0.4);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "rgba(0, 0, 0, 0.4)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, plant.r * 0.35);
      ctx.lineTo(0, -plant.r * 1.1);
      ctx.stroke();

      ctx.restore();
    }

    function drawStar(star) {
      const screenX = star.x - state.cameraX;
      const y = star.y;
      const spikes = 5;
      const outer = star.r;
      const inner = star.r * 0.5;
      let rot = Math.PI / 2 * 3;
      let x = screenX;
      let yPos = y;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x, yPos - outer);
      for (let i = 0; i < spikes; i += 1) {
        x = screenX + Math.cos(rot) * outer;
        yPos = y + Math.sin(rot) * outer;
        ctx.lineTo(x, yPos);
        rot += Math.PI / spikes;

        x = screenX + Math.cos(rot) * inner;
        yPos = y + Math.sin(rot) * inner;
        ctx.lineTo(x, yPos);
        rot += Math.PI / spikes;
      }
      ctx.lineTo(screenX, y - outer);
      ctx.closePath();
      ctx.fillStyle = "#f2c94c";
      ctx.shadowColor = "rgba(242, 201, 76, 0.6)";
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function draw() {
      drawBackground();

      for (const plat of platforms) {
        drawPlatform({
          x: plat.x - state.cameraX,
          y: plat.y,
          w: plat.w,
          h: plat.h
        });
      }

      ctx.shadowColor = "rgba(255, 178, 0, 0.35)";
      ctx.shadowBlur = 12;
      for (const item of collectibles) {
        drawCigarettes(item);
      }
      ctx.shadowBlur = 0;

      for (const obs of obstacles) {
        if (obs.type === "housing") {
          drawHousingEnemy(obs);
        } else if (obs.type === "heli") {
          drawHelicopter(obs);
        } else if (obs.type === "bird") {
          drawBird(obs);
        } else {
          drawRoach(obs);
        }
      }

      drawBillMan();

      for (const fireball of fireballs) {
        const screenX = fireball.x - state.cameraX;
        const w = fireball.r * 2.4;
        const h = fireball.r * 1.4;
        ctx.save();
        ctx.translate(screenX, fireball.y);
        ctx.rotate(Math.atan2(fireball.vy || 0, fireball.vx || 1));
        ctx.fillStyle = "#f2efe6";
        ctx.strokeStyle = "rgba(15, 15, 20, 0.6)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        if (ctx.roundRect) {
          ctx.roundRect(-w / 2, -h / 2, w, h, 4);
        } else {
          ctx.rect(-w / 2, -h / 2, w, h);
        }
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = "#ff5a4f";
        ctx.fillRect(-w / 2 + 3, -h / 2 + 3, w * 0.35, h * 0.25);
        ctx.restore();
      }

      ctx.fillStyle = "#ff5a4f";
      for (const shot of enemyShots) {
        const screenX = shot.x - state.cameraX;
        ctx.beginPath();
        ctx.shadowColor = "rgba(255, 90, 79, 0.6)";
        ctx.shadowBlur = 8;
        ctx.arc(screenX, shot.y, shot.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      ctx.fillStyle = "#ff8f3d";
      for (const rocket of billRockets) {
        const screenX = rocket.x - state.cameraX;
        ctx.beginPath();
        ctx.shadowColor = "rgba(255, 143, 61, 0.6)";
        ctx.shadowBlur = 10;
        ctx.arc(screenX, rocket.y, rocket.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      ctx.fillStyle = "#ff5a4f";
      for (const shot of billFireballs) {
        const screenX = shot.x - state.cameraX;
        ctx.beginPath();
        ctx.shadowColor = "rgba(255, 90, 79, 0.6)";
        ctx.shadowBlur = 8;
        ctx.arc(screenX, shot.y, shot.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      for (const plant of plants) {
        drawPlant(plant);
      }

      for (const star of stars) {
        drawStar(star);
      }

      drawTrapHouse();
      drawCopCar();
      drawDogs();
      drawCopBoss();
      drawCourier();
      drawKid();

      if (state.collectMessageTimer > 0) {
        ctx.save();
        ctx.fillStyle = "#ffb200";
        ctx.font = "bold 18px \"Trebuchet MS\", sans-serif";
        ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
        ctx.shadowBlur = 6;
        const screenX = player.x - state.cameraX;
        ctx.fillText("yeah yeah", screenX + player.w * 0.2, player.y - 12);
        ctx.restore();
      }

      if (state.fireMessageTimer > 0) {
        ctx.save();
        ctx.fillStyle = "#ff5a4f";
        ctx.font = "bold 16px \"Trebuchet MS\", sans-serif";
        ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
        ctx.shadowBlur = 6;
        const screenX = player.x - state.cameraX;
        ctx.fillText("EBT attack", screenX + player.w * 0.2, player.y - 34);
        ctx.restore();
      }

      if (state.invincibleTimer > 0) {
        const screenX = player.x - state.cameraX;
        ctx.save();
        ctx.strokeStyle = "#ff5a4f";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(screenX + player.w * 0.5, player.y - 10, 14, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(screenX + player.w * 0.5 - 8, player.y - 22);
        ctx.lineTo(screenX + player.w * 0.5 - 2, player.y - 32);
        ctx.lineTo(screenX + player.w * 0.5 + 2, player.y - 22);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(screenX + player.w * 0.5 + 8, player.y - 22);
        ctx.lineTo(screenX + player.w * 0.5 + 2, player.y - 32);
        ctx.lineTo(screenX + player.w * 0.5 - 2, player.y - 22);
        ctx.stroke();
        ctx.restore();
      }

      if (state.beltTimer > 0) {
        const screenX = player.x - state.cameraX;
        const dir = player.facing || 1;
        ctx.save();
        ctx.strokeStyle = "#c9b08a";
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(screenX + player.w * 0.5, player.y + player.h * 0.5);
        ctx.lineTo(screenX + player.w * 0.5 + dir * 40, player.y + player.h * 0.35);
        ctx.stroke();
        ctx.restore();
      }
    }

    function loop(now) {
      const dt = Math.min(0.033, (now - state.lastFrame) / 1000);
      state.lastFrame = now;

      if (input.jumpQueued) {
        input.jumpQueued = false;
        handleJump();
      }
      if (input.fireQueued) {
        input.fireQueued = false;
        shootFireball();
      }
      if (input.beltQueued) {
        input.beltQueued = false;
        swingBelt();
      }

      update(dt);
      draw();

      hudScore.textContent = Math.floor(state.score).toString();
      const meterValue = Math.max(0, Math.min(100, state.meter));
      meterFill.style.width = `${meterValue}%`;
      meterText.textContent = `${Math.round(meterValue)}%`;
      if (meterValueLabel) {
        meterValueLabel.textContent = `${Math.round(meterValue)}%`;
      }
      if (burstCount) {
        burstCount.textContent = `${state.burstCharges}`;
      }

      if (state.collectMessageTimer > 0) {
        state.collectMessageTimer -= dt;
      }
      if (state.fireMessageTimer > 0) {
        state.fireMessageTimer -= dt;
      }
      if (state.invincibleTimer > 0) {
        state.invincibleTimer -= dt;
      }
      if (state.beltTimer > 0) {
        state.beltTimer -= dt;
      }
      if (state.kidAlive && state.kidBurstCount > 0) {
        state.kidBurstTimer -= dt;
        if (state.kidBurstTimer <= 0) {
          const dir = player.facing || 1;
          fireballs.push({
            x: state.kidX + 10,
            y: state.kidY + 22,
            r: 6,
            vx: dir * 420,
            vy: 0,
            life: 1.6,
            type: "kid"
          });
          state.kidBurstCount -= 1;
          state.kidBurstTimer = 0.5;
        }
      }

      requestAnimationFrame(loop);
    }

    window.addEventListener("resize", () => {
      resize();
    });

    window.addEventListener("keydown", (event) => {
      hasUserInteracted = true;
      if (event.code === "Space" || event.code === "ArrowUp" || event.code === "KeyW") {
        event.preventDefault();
        queueJump();
        if (!state.spokenStart && state.running && !state.dead) {
          speakYeah();
          state.spokenStart = true;
        }
      }
      if (event.code === "KeyF") {
        queueFire();
      }
      if (event.code === "KeyG") {
        releaseBurst();
      }
      if (event.code === "ArrowLeft" || event.code === "KeyA") {
        input.left = true;
      }
      if (event.code === "ArrowRight" || event.code === "KeyD") {
        input.right = true;
      }
      if (event.code === "ArrowDown" || event.code === "KeyS") {
        input.down = true;
      }
      if (event.code === "KeyR" && state.dead) {
        resetGame();
      }
    });

    window.addEventListener("keyup", (event) => {
      if (event.code === "ArrowLeft" || event.code === "KeyA") {
        input.left = false;
      }
      if (event.code === "ArrowRight" || event.code === "KeyD") {
        input.right = false;
      }
      if (event.code === "ArrowDown" || event.code === "KeyS") {
        input.down = false;
      }
    });

    window.addEventListener("blur", () => {
      input.left = false;
      input.right = false;
      input.down = false;
      input.jumpQueued = false;
      input.fireQueued = false;
      input.beltQueued = false;
    });

    canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });

    canvas.addEventListener("mousedown", (event) => {
      if (event.button === 2) {
        hasUserInteracted = true;
        queueBelt();
        return;
      }
      if (event.button !== 0) return;
      hasUserInteracted = true;
      queueFire();
    });

    window.addEventListener("pointerdown", (event) => {
      if (isTouch || event.button !== 0) return;
      hasUserInteracted = true;
      queueFire();
    }, { passive: true });

    if (fireBtn) {
      fireBtn.addEventListener("click", () => {
        hasUserInteracted = true;
        queueFire();
      });
    }

    if (burstBtn) {
      burstBtn.addEventListener("click", () => {
        hasUserInteracted = true;
        releaseBurst();
      });
    }

    if (voiceToggle) {
      voiceToggle.addEventListener("click", () => {
        state.voiceEnabled = !state.voiceEnabled;
        voiceToggle.textContent = state.voiceEnabled ? "Voice On" : "Voice Off";
      });
    }

    if (restartBtn) {
      restartBtn.addEventListener("click", () => {
        hasUserInteracted = true;
        if (state.deathCause === "win") {
          const nextLevel = state.level >= levelConfigs.length ? 1 : state.level + 1;
          resetGame(nextLevel);
        } else {
          resetGame(state.level);
        }
      });
    }

    function bindHold(btn, onDown, onUp) {
      if (!btn) return;
      btn.addEventListener("pointerdown", (event) => {
        event.preventDefault();
        hasUserInteracted = true;
        onDown();
      }, { passive: false });
      btn.addEventListener("pointerup", (event) => {
        event.preventDefault();
        onUp();
      }, { passive: false });
      btn.addEventListener("pointerleave", onUp);
      btn.addEventListener("pointercancel", onUp);
    }

    if (isTouch) {
      let dpadPointerId = null;
      let dpadJumped = false;

      function updateDpadFromPoint(clientX, clientY) {
        if (!dpad) return;
        const rect = dpad.getBoundingClientRect();
        const cx = rect.left + rect.width * 0.5;
        const cy = rect.top + rect.height * 0.5;
        const dx = clientX - cx;
        const dy = clientY - cy;
        const threshold = Math.min(rect.width, rect.height) * 0.18;
        input.left = dx < -threshold;
        input.right = dx > threshold;
        input.down = dy > threshold;
        if (dy < -threshold) {
          if (!dpadJumped) {
            queueJump();
            if (!state.spokenStart && state.running && !state.dead) {
              speakYeah();
              state.spokenStart = true;
            }
            dpadJumped = true;
          }
        } else {
          dpadJumped = false;
        }
      }

      if (dpad) {
        dpad.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          hasUserInteracted = true;
          dpadPointerId = event.pointerId;
          if (dpad.setPointerCapture) {
            dpad.setPointerCapture(event.pointerId);
          }
          updateDpadFromPoint(event.clientX, event.clientY);
        }, { passive: false });
        dpad.addEventListener("pointermove", (event) => {
          if (event.pointerId !== dpadPointerId) return;
          event.preventDefault();
          updateDpadFromPoint(event.clientX, event.clientY);
        }, { passive: false });
        const clearDpad = (event) => {
          if (event.pointerId !== dpadPointerId) return;
          event.preventDefault();
          if (dpad.releasePointerCapture && dpad.hasPointerCapture && dpad.hasPointerCapture(event.pointerId)) {
            dpad.releasePointerCapture(event.pointerId);
          }
          dpadPointerId = null;
          input.left = false;
          input.right = false;
          input.down = false;
          dpadJumped = false;
        };
        dpad.addEventListener("pointerup", clearDpad, { passive: false });
        dpad.addEventListener("pointercancel", clearDpad, { passive: false });
        window.addEventListener("pointerup", clearDpad, { passive: false });
        window.addEventListener("pointercancel", clearDpad, { passive: false });
      }

      if (fireBtn) {
        fireBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          hasUserInteracted = true;
          queueFire();
        }, { passive: false });
      }

      if (burstBtn) {
        burstBtn.addEventListener("touchstart", (event) => {
          event.preventDefault();
          hasUserInteracted = true;
          releaseBurst();
        }, { passive: false });
      }
    }

    resize();
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>

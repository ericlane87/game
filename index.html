<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The Adventures of the Yeah, Yeah Man</title>
  <style>
    :root {
      --ink: #0f0f14;
      --cream: #f6f1e8;
      --neon: #ffb200;
      --heat: #ff5a4f;
      --electric: #4ad9d9;
      --shadow: rgba(10, 10, 18, 0.55);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Trebuchet MS", "Lucida Sans Unicode", "Lucida Grande", sans-serif;
      background:
        radial-gradient(circle at 20% 20%, rgba(255, 90, 79, 0.25), transparent 45%),
        radial-gradient(circle at 80% 10%, rgba(74, 217, 217, 0.2), transparent 35%),
        linear-gradient(140deg, #111018 0%, #231d2f 45%, #1b222e 100%);
      color: var(--cream);
      overflow: hidden;
      height: 100vh;
    }

    #stage {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: transparent;
    }

    #hud {
      position: absolute;
      top: 44px;
      left: 20px;
      right: 20px;
      z-index: 2;
      display: flex;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 700;
    }

    #hud-title {
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      font-family: "Impact", "Arial Black", sans-serif;
      font-size: clamp(18px, 2.4vw, 28px);
      font-weight: 900;
      color: var(--neon);
      text-shadow: 0 10px 18px var(--shadow);
      letter-spacing: 0.06em;
      pointer-events: none;
      white-space: nowrap;
    }

    #voice-toggle {
      pointer-events: auto;
      background: rgba(18, 16, 24, 0.8);
      color: var(--cream);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 8px 10px;
      font-weight: 800;
      letter-spacing: 0.08em;
      cursor: pointer;
      box-shadow: 0 10px 20px var(--shadow);
    }

    #voice-toggle:active {
      transform: translateY(1px) scale(0.98);
    }

    #hud .score {
      font-size: 14px;
      background: rgba(18, 16, 24, 0.75);
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 10px 20px var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    #meter {
      flex: 1;
      max-width: 360px;
      min-width: 160px;
      height: 22px;
      border-radius: 999px;
      background: rgba(15, 15, 20, 0.65);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.45);
      box-shadow: 0 10px 20px var(--shadow);
      position: relative;
    }

    #meter-fill {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--neon), var(--heat));
      transition: width 0.1s ease-out;
      box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.3);
    }

    #meter-text {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.08em;
      color: rgba(246, 241, 232, 0.95);
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
    }

    #overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(11, 10, 18, 0.5);
      backdrop-filter: blur(6px);
      text-align: center;
      padding: 24px;
    }

    #overlay.hidden {
      display: none;
    }

    #title {
      font-family: "Impact", "Arial Black", sans-serif;
      font-size: clamp(32px, 6vw, 72px);
      margin: 0;
      color: var(--neon);
      text-shadow: 0 16px 30px var(--shadow);
      letter-spacing: 0.04em;
    }

    #subtitle {
      margin: 12px 0 0;
      font-size: clamp(14px, 2.4vw, 20px);
      max-width: 520px;
      color: rgba(246, 241, 232, 0.85);
    }

    #controls {
      margin-top: 22px;
      font-size: 13px;
      opacity: 0.8;
    }

    #death-reason {
      margin-top: 10px;
      font-weight: 700;
      color: rgba(246, 241, 232, 0.9);
    }

    #restart-btn {
      margin-top: 16px;
      font-family: inherit;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      background: var(--neon);
      color: #141018;
      border: none;
      border-radius: 999px;
      padding: 12px 22px;
      cursor: pointer;
      box-shadow: 0 12px 24px var(--shadow);
    }

    #restart-btn:active {
      transform: translateY(1px) scale(0.98);
    }

    #touch-controls {
      position: absolute;
      right: 16px;
      bottom: 20px;
      display: none;
      align-items: flex-end;
      pointer-events: auto;
    }

    #action-buttons button {
      font-family: inherit;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(18, 16, 24, 0.85);
      color: var(--cream);
      border: 1px solid rgba(255, 255, 255, 0.14);
      border-radius: 18px;
      padding: 12px 16px;
      box-shadow: 0 12px 24px var(--shadow);
    }

    #action-buttons {
      display: flex;
      flex-direction: column;
    }

    #action-buttons button {
      width: 84px;
      height: 58px;
    }

    #touch-controls button:active {
      transform: translateY(1px) scale(0.98);
    }

    .is-touch #touch-controls {
      display: flex;
    }

    @media (max-width: 700px) {
      #hud {
        flex-direction: column;
        align-items: stretch;
      }

      #hud .score {
        width: 100%;
        text-align: center;
      }

      #meter {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="game" aria-label="Stoop Runner"></canvas>

    <div id="hud">
      <div id="hud-title">The Adventures of the Yeah, Yeah Man</div>
      <div class="score">Score: <span id="score">0</span></div>
      <div id="meter" aria-label="Addiction meter">
        <div id="meter-fill"></div>
        <div id="meter-text">100</div>
      </div>
      <div class="score">Addiction: <span id="meter-value">100%</span></div>
      <button id="voice-toggle" type="button" aria-label="Toggle voice">Voice On</button>
    </div>

    <div id="overlay">
      <div>
        <h1 id="title">The Adventures of the Yeah, Yeah Man</h1>
        <p id="subtitle">Sprint the block. Dodge roaches. Grab the stash to keep your meter alive.</p>
        <div id="death-reason"></div>
        <div id="controls">Desktop: A-D to move, Space to jump, left click/F to fire, right click for belt. Mobile: drag to move, tap to jump, Fire/Belt buttons.</div>
        <button id="restart-btn" type="button">New Game</button>
      </div>
    </div>

    <div id="touch-controls">
      <div id="action-buttons">
        <button id="fire-btn" type="button">Fire</button>
        <button id="belt-btn" type="button">Belt</button>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const hudScore = document.getElementById("score");
    const meterFill = document.getElementById("meter-fill");
    const meterText = document.getElementById("meter-text");
    const meterValueLabel = document.getElementById("meter-value");
    const overlay = document.getElementById("overlay");
    const deathReason = document.getElementById("death-reason");
    const fireBtn = document.getElementById("fire-btn");
    const beltBtn = document.getElementById("belt-btn");
    const restartBtn = document.getElementById("restart-btn");
    const voiceToggle = document.getElementById("voice-toggle");

    const isTouch = "ontouchstart" in window || navigator.maxTouchPoints > 0;
    const isDesktop = !isTouch;
    const voicePreference = {
      name: "David"
    };
    let cachedVoice = null;
    if (isTouch) {
      document.body.classList.add("is-touch");
    }

    const input = {
      jumpQueued: false,
      fireQueued: false,
      beltQueued: false,
      left: false,
      right: false
    };

    const touchMove = {
      active: false,
      id: null,
      startX: 0,
      lastX: 0,
      moved: false
    };

    const world = {
      width: 0,
      height: 0,
      groundY: 0,
      scale: 1
    };

    const player = {
      x: 0,
      y: 0,
      w: 36,
      h: 52,
      vy: 0,
      vx: 0,
      facing: 1,
      jumpsLeft: 1,
      color: "#f6f1e8"
    };

    const state = {
      running: false,
      dead: false,
      moveSpeed: 240,
      score: 0,
      meter: 100,
      meterDrain: 1,
      meterAdd: 20,
      gravity: 1600,
      jumpPower: 640,
      time: 0,
      lastSpawn: 0,
      lastCollectible: 0,
      lastPlatform: 0,
      lastObstacleX: 0,
      lastCollectibleX: 0,
      lastPlatformX: 0,
      lastFrame: performance.now(),
      distance: 0,
      cameraX: 0,
      collectMessageTimer: 0,
      fireMessageTimer: 0,
      deathCause: "",
      initialDropTimer: 0,
      level: 1,
      levelEndX: 7800,
      goalLabel: "TRAP HOUSE",
      flameShots: 0,
      enemyShotTimer: 0,
      billManActive: false,
      billManX: 0,
      billManY: 0,
      billManHp: 10,
      billManW: 56,
      billManH: 90,
      billRocketTimer: 0,
      billFollowUpTimer: 0,
      billJumpTimer: 0,
      billJumpOffset: 0,
      beltTimer: 0,
      kidX: 0,
      kidY: 0,
      kidHits: 0,
      kidAlive: true,
      lastPlant: 0,
      voiceEnabled: true,
      spokenStart: false
    };

    const obstacles = [];
    const platforms = [];
    const collectibles = [];
    const fireballs = [];
    const plants = [];
    const enemyShots = [];
    const billRockets = [];
    const billFireballs = [];
    let hasUserInteracted = false;

    function resize() {
      const ratio = window.devicePixelRatio || 1;
      world.width = window.innerWidth;
      world.height = window.innerHeight;
      world.groundY = world.height * 0.78;
      world.scale = ratio;
      canvas.width = world.width * ratio;
      canvas.height = world.height * ratio;
      canvas.style.width = `${world.width}px`;
      canvas.style.height = `${world.height}px`;
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);

      const isMobile = isTouch || world.width < 900;
      player.w = isMobile ? 30 : 40;
      player.h = isMobile ? 46 : 58;
      player.x = Math.max(player.x, 120);
      player.y = world.groundY - player.h;
      state.jumpPower = isMobile ? 620 : 720;
      state.moveSpeed = isMobile ? 220 : 260;
    }

    function resetGame(nextLevel = state.level) {
      state.level = nextLevel;
      state.running = true;
      state.dead = false;
      state.score = 0;
      state.meter = 100;
      state.time = 0;
      state.lastSpawn = 0;
      state.lastCollectible = 0;
      state.lastPlatform = 0;
      state.lastObstacleX = 0;
      state.lastCollectibleX = 0;
      state.lastPlatformX = 0;
      state.distance = 0;
      state.cameraX = 0;
      state.deathCause = "";
      state.flameShots = 0;
      state.enemyShotTimer = 0;
      state.billManActive = false;
      state.billManX = 0;
      state.billManY = 0;
      state.billManHp = 10;
      state.billRocketTimer = 0;
      state.billFollowUpTimer = 0;
      state.billJumpTimer = 0;
      state.billJumpOffset = 0;
      state.lastPlant = 0;
      state.kidHits = 0;
      state.kidAlive = true;
      state.spokenStart = false;
      obstacles.length = 0;
      platforms.length = 0;
      collectibles.length = 0;
      fireballs.length = 0;
      plants.length = 0;
      enemyShots.length = 0;
      billRockets.length = 0;
      billFireballs.length = 0;
      player.x = 160;
      player.y = world.groundY - player.h;
      player.vy = 0;
      player.vx = 0;
      player.jumpsLeft = 1;
      overlay.classList.add("hidden");
      restartBtn.textContent = "New Game";
      state.initialDropTimer = 3;
      state.levelEndX = state.level === 2 ? 9000 : 7800;
      state.goalLabel = state.level === 2 ? "ROACH MOTEL" : "TRAP HOUSE";
      if (state.level === 1) {
        state.billManX = state.levelEndX * 0.5 + world.width * 0.6;
        state.billManY = world.groundY - 84;
      }
      seedPlatformsForLevel(state.level);
      seedStartPlant();
      for (let i = 0; i < 3; i += 1) {
        spawnObstacle();
      }
      for (let i = 0; i < 3; i += 1) {
        spawnObstacle();
      }

      if (hasUserInteracted) {
        speakYeah();
        state.spokenStart = true;
      }
    }

    function die() {
      state.running = false;
      state.dead = true;
      const meterValue = Math.max(0, Math.min(100, state.meter));
      const reasonText = state.deathCause === "meter"
        ? "Addiction meter drained."
        : state.deathCause === "win"
          ? `Level ${state.level} complete.`
        : state.deathCause === "enemy"
            ? "You got caught."
            : "You got caught.";
      deathReason.textContent = `${reasonText} Meter: ${Math.round(meterValue)}%`;
      if (state.deathCause === "win") {
        restartBtn.textContent = state.level === 1 ? "Next Level" : "New Game";
      } else {
        restartBtn.textContent = "New Game";
      }
      overlay.classList.remove("hidden");
    }

    function winLevel() {
      state.deathCause = "win";
      die();
    }

    function queueJump() {
      input.jumpQueued = true;
    }

    function queueFire() {
      input.fireQueued = true;
    }

    function queueBelt() {
      input.beltQueued = true;
    }

    function selectVoice() {
      const voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
      if (!voices.length) return null;
      if (cachedVoice && voices.includes(cachedVoice)) {
        return cachedVoice;
      }
      const match = voices.find((voice) =>
        voice.name && voice.name.toLowerCase().includes(voicePreference.name.toLowerCase())
      );
      cachedVoice = match || null;
      return cachedVoice;
    }

    if ("speechSynthesis" in window) {
      window.speechSynthesis.onvoiceschanged = () => {
        selectVoice();
      };
    }

    function speakYeah() {
      if (!state.voiceEnabled) return;
      if (!("speechSynthesis" in window)) return;
      const utter = new SpeechSynthesisUtterance("yeah, yeah");
      const voice = selectVoice();
      if (voice) utter.voice = voice;
      utter.rate = 1.05;
      utter.pitch = 1.1;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utter);
    }

    function speakGreenThing() {
      if (!state.voiceEnabled) return;
      if (!("speechSynthesis" in window)) return;
      const utter = new SpeechSynthesisUtterance("Green Thing Time");
      const voice = selectVoice();
      if (voice) utter.voice = voice;
      utter.rate = 1.0;
      utter.pitch = 1.0;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(utter);
    }

    function handleJump() {
      if (state.dead || !state.running) {
        resetGame();
        return;
      }
      if (player.jumpsLeft > 0) {
        player.vy = -state.jumpPower;
        player.jumpsLeft -= 1;
        if (state.kidAlive) {
          const dir = player.facing || 1;
          fireballs.push({
            x: state.kidX + 10,
            y: state.kidY + 22,
            r: 6,
            vx: dir * 420,
            vy: 0,
            life: 1.6,
            type: "kid"
          });
        }
      }
    }

    function shootFireball() {
      if (state.dead || !state.running) return;
      const dir = player.facing || 1;
      if (state.flameShots > 0) {
        const baseX = player.x + player.w * 0.6;
        const baseY = player.y + player.h * 0.4;
        const angles = [-Math.PI / 2, -Math.PI / 6, -Math.PI / 3, Math.PI / 6, Math.PI / 3, Math.PI / 2];
        const speed = 380;
        angles.forEach((angle) => {
          fireballs.push({
            x: baseX,
            y: baseY,
            r: 9,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.4,
            type: "burst"
          });
        });
        state.flameShots = 0;
      } else {
        fireballs.push({
          x: player.x + player.w * 0.6,
          y: player.y + player.h * 0.4,
          r: 8,
          vx: dir * 520,
          vy: 0,
          life: 2.2,
          type: "fireball"
        });
      }
      state.fireMessageTimer = 0.6;
    }

    function swingBelt() {
      if (state.dead || !state.running) return;
      state.beltTimer = 0.25;
      const dir = player.facing || 1;
      const hitbox = {
        x: player.x + (dir > 0 ? player.w : -40),
        y: player.y + 10,
        w: 40,
        h: player.h - 20
      };

      for (let i = obstacles.length - 1; i >= 0; i -= 1) {
        if (rectsOverlap(hitbox, obstacles[i])) {
          obstacles.splice(i, 1);
          state.score += 6;
        }
      }

      if (state.billManActive && state.billManHp > 0) {
        const bossBox = {
          x: state.billManX - state.billManW * 0.5,
          y: state.billManY,
          w: state.billManW,
          h: state.billManH
        };
        if (rectsOverlap(hitbox, bossBox)) {
          state.billManHp = Math.max(0, state.billManHp - 2);
          if (state.billManHp <= 0) {
            state.billManActive = false;
          }
        }
      }
    }

    function spawnObstacle() {
      const roll = Math.random();
      const isHousing = state.level === 2 ? roll < 0.35 : roll < 0.2;
      const isHeli = state.level === 2 && !isHousing && roll < 0.55;
      const size = isHeli ? 38 : isHousing ? 46 : 28 + Math.random() * 10;
      const width = isHousing ? size * 0.9 : size * 1.2;
      const spawnX = Math.max(
        state.cameraX + world.width + 180,
        state.lastObstacleX + 280 + Math.random() * 240
      );
      const onPlatform = platforms.length && Math.random() < 0.6;
      let y = world.groundY - size;
      if (isHeli) {
        y = world.groundY - 220 - Math.random() * 120;
      } else if (onPlatform) {
        const plat = platforms[Math.floor(Math.random() * platforms.length)];
        y = plat.y - size;
      }
      obstacles.push({
        x: spawnX,
        y,
        w: width,
        h: size,
        type: isHeli ? "heli" : isHousing ? "housing" : "roach",
        speed: (isHeli ? 120 : isHousing ? 70 : 90) + state.distance * 0.03 + Math.random() * 35,
        vx: -1,
        phase: Math.random() * Math.PI * 2,
        hp: isHeli ? 2 + Math.floor(Math.random() * 2) : 1
      });
      state.lastObstacleX = spawnX;
    }

    function spawnCollectible() {
      const r = 10;
      const spawnX = Math.max(
        state.cameraX + world.width + 160,
        state.lastCollectibleX + 280 + Math.random() * 240
      );
      const onPlatform = platforms.length && Math.random() < 0.6;
      let y = world.groundY - 50 - Math.random() * 40;
      if (onPlatform) {
        const plat = platforms[Math.floor(Math.random() * platforms.length)];
        y = plat.y - 24;
      }
      collectibles.push({
        x: spawnX,
        y,
        r
      });
      state.lastCollectibleX = spawnX;
    }

    function spawnPlatform() {
      const w = 140 + Math.random() * 140;
      const h = 14;
      const yOptions = state.level === 2
        ? [world.groundY - 140, world.groundY - 220, world.groundY - 300, world.groundY - 380]
        : [world.groundY - 120, world.groundY - 200, world.groundY - 280, world.groundY - 340];
      const y = yOptions[Math.floor(Math.random() * yOptions.length)];
      const spawnX = Math.max(
        state.cameraX + world.width + 160,
        state.lastPlatformX + 200 + Math.random() * 160
      );
      platforms.push({ x: spawnX, y, w, h });
      state.lastPlatformX = spawnX;
    }

    function spawnLowPlatformChain() {
      const baseX = Math.max(
        state.cameraX + world.width + 120,
        state.lastPlatformX + 140
      );
      const y = world.groundY - 120;
      const widths = [140, 160, 180];
      for (let i = 0; i < 2; i += 1) {
        const w = widths[Math.floor(Math.random() * widths.length)];
        const x = baseX + i * (w + 90);
        platforms.push({ x, y, w, h: 14 });
        state.lastPlatformX = Math.max(state.lastPlatformX, x + w);
      }
    }

    function seedPlatformsForLevel(level) {
      const baseX = player.x + 220;
      const layouts = level === 2
        ? [
            { x: baseX, y: world.groundY - 160, w: 200 },
            { x: baseX + 280, y: world.groundY - 260, w: 180 },
            { x: baseX + 560, y: world.groundY - 200, w: 220 },
            { x: baseX + 860, y: world.groundY - 320, w: 160 },
            { x: baseX + 1120, y: world.groundY - 240, w: 240 }
          ]
        : [
            { x: baseX, y: world.groundY - 140, w: 220 },
            { x: baseX + 260, y: world.groundY - 220, w: 180 },
            { x: baseX + 520, y: world.groundY - 180, w: 240 },
            { x: baseX + 820, y: world.groundY - 300, w: 180 },
            { x: baseX + 1060, y: world.groundY - 220, w: 220 }
          ];
      layouts.forEach((plat) => {
        platforms.push({ x: plat.x, y: plat.y, w: plat.w, h: 14 });
        state.lastPlatformX = Math.max(state.lastPlatformX, plat.x + plat.w);
      });
      for (let i = 0; i < 4; i += 1) {
        spawnPlatform();
      }
    }

    function seedStartPlant() {
      plants.push({
        x: player.x + 160,
        y: world.groundY - 60,
        r: 14
      });
    }

    function spawnPlant() {
      const spawnX = Math.max(
        state.cameraX + world.width + 220,
        state.lastCollectibleX + 320 + Math.random() * 260
      );
      const highY = state.level === 2 ? world.groundY - 360 : world.groundY - 320;
      plants.push({
        x: spawnX,
        y: highY,
        r: 14
      });
      state.lastCollectibleX = spawnX;
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function update(dt) {
      if (!state.running) return;

      state.time += dt;
      const moveDir = (input.right ? 1 : 0) - (input.left ? 1 : 0);
      player.vx = moveDir * state.moveSpeed;
      if (moveDir !== 0) {
        player.facing = moveDir;
      }
      player.x = Math.max(state.cameraX + 40, player.x + player.vx * dt);

      if (player.x > state.distance) {
        state.distance = player.x;
      }
      state.kidX = player.x - 70;
      state.kidY = world.groundY - 48;
      if (state.kidX < state.cameraX + 20) {
        state.kidX = state.cameraX + 20;
      }
      state.score = Math.floor(state.distance * 0.08);
      state.meter = Math.max(0, state.meter - state.meterDrain * dt);
      if (state.meter <= 0) {
        state.deathCause = "meter";
        die();
        return;
      }

      if (state.initialDropTimer > 0) {
        state.initialDropTimer -= dt;
        if (state.initialDropTimer <= 0) {
          const startY = world.groundY - 60;
          collectibles.push(
            { x: player.x + 140, y: startY, r: 10 },
            { x: player.x + 260, y: startY, r: 10 }
          );
          state.lastCollectibleX = player.x + 260;
        }
      }

      state.cameraX = Math.max(state.cameraX, player.x - world.width * 0.3);

      if (player.x + player.w >= state.levelEndX) {
        winLevel();
        return;
      }

      if (platforms.length < 14 && state.time - state.lastPlatform > 0.5) {
        spawnPlatform();
        state.lastPlatform = state.time;
      }
      if (state.time - state.lastPlatform > 1.4 && Math.random() < 0.4) {
        spawnLowPlatformChain();
        state.lastPlatform = state.time;
      }

      if (state.time - state.lastSpawn > 0.7 + Math.random() * 0.9) {
        spawnObstacle();
        state.lastSpawn = state.time;
      }

      if (state.time - state.lastCollectible > 0.9 + Math.random() * 1.1) {
        spawnCollectible();
        state.lastCollectible = state.time;
      }

      if (state.time - state.lastPlant > 2.6 && Math.random() < 0.7) {
        spawnPlant();
        state.lastPlant = state.time;
      }

      if (state.level === 1 && !state.billManActive && player.x >= state.billManX - world.width * 0.9) {
        state.billManActive = true;
        state.billRocketTimer = state.time;
      }

      if (state.billManActive) {
        const targetDir = player.x > state.billManX ? 1 : -1;
        state.billManX += targetDir * 90 * dt;
        state.billManY = world.groundY - state.billManH - state.billJumpOffset;

        if (state.time - state.billRocketTimer >= 3) {
          const targetY = player.y + player.h * 0.5;
          billRockets.push({
            x: state.billManX,
            y: targetY,
            r: 10,
            vx: player.x > state.billManX ? 260 : -260,
            life: 4
          });
          state.billRocketTimer = state.time;
          state.billFollowUpTimer = state.time + 1;
        }
        if (state.billFollowUpTimer > 0 && state.time >= state.billFollowUpTimer) {
          const targetY = player.y + player.h * 0.5;
          billFireballs.push({
            x: state.billManX,
            y: targetY,
            r: 7,
            vx: player.x > state.billManX ? 320 : -320,
            life: 3
          });
          state.billFollowUpTimer = 0;
        }

        if (state.time - state.billJumpTimer >= 4.5) {
          state.billJumpTimer = state.time;
          state.billJumpOffset = 32;
        }
        if (state.billJumpOffset > 0) {
          state.billJumpOffset = Math.max(0, state.billJumpOffset - 120 * dt);
        }
      }

      if (state.level === 2 && state.time - state.enemyShotTimer >= 5) {
        const helis = obstacles.filter((obs) => obs.type === "heli");
        if (helis.length) {
          const shooter = helis[Math.floor(Math.random() * helis.length)];
          enemyShots.push({
            x: shooter.x,
            y: shooter.y + shooter.h * 0.6,
            r: 6,
            vx: -220,
            life: 3
          });
        }
        state.enemyShotTimer = state.time;
      }

      obstacles.forEach((obs) => {
        const dir = obs.x > player.x ? -1 : 1;
        obs.x += dir * obs.speed * dt;
      });

      fireballs.forEach((fireball) => {
        fireball.x += fireball.vx * dt;
        fireball.y += (fireball.vy || 0) * dt;
        fireball.life -= dt;
      });

      enemyShots.forEach((shot) => {
        shot.x += shot.vx * dt;
        shot.life -= dt;
      });

      billRockets.forEach((rocket) => {
        rocket.x += rocket.vx * dt;
        rocket.life -= dt;
      });

      billFireballs.forEach((shot) => {
        shot.x += shot.vx * dt;
        shot.life -= dt;
      });

      const cleanupX = state.cameraX - 200;
      for (let i = platforms.length - 1; i >= 0; i -= 1) {
        if (platforms[i].x + platforms[i].w < cleanupX) {
          platforms.splice(i, 1);
        }
      }
      for (let i = obstacles.length - 1; i >= 0; i -= 1) {
        if (obstacles[i].x + obstacles[i].w < cleanupX) {
          obstacles.splice(i, 1);
        }
      }
      for (let i = collectibles.length - 1; i >= 0; i -= 1) {
        if (collectibles[i].x + collectibles[i].r < cleanupX) {
          collectibles.splice(i, 1);
        }
      }
      for (let i = plants.length - 1; i >= 0; i -= 1) {
        if (plants[i].x + plants[i].r < cleanupX) {
          plants.splice(i, 1);
        }
      }
      for (let i = fireballs.length - 1; i >= 0; i -= 1) {
        if (fireballs[i].life <= 0 || fireballs[i].x < cleanupX || fireballs[i].x > state.cameraX + world.width + 200) {
          fireballs.splice(i, 1);
        }
      }
      for (let i = enemyShots.length - 1; i >= 0; i -= 1) {
        if (enemyShots[i].life <= 0 || enemyShots[i].x < cleanupX) {
          enemyShots.splice(i, 1);
        }
      }
      for (let i = billRockets.length - 1; i >= 0; i -= 1) {
        if (billRockets[i].life <= 0 || billRockets[i].x < cleanupX || billRockets[i].x > state.cameraX + world.width + 200) {
          billRockets.splice(i, 1);
        }
      }
      for (let i = billFireballs.length - 1; i >= 0; i -= 1) {
        if (billFireballs[i].life <= 0 || billFireballs[i].x < cleanupX || billFireballs[i].x > state.cameraX + world.width + 200) {
          billFireballs.splice(i, 1);
        }
      }

      const prevY = player.y;
      player.vy += state.gravity * dt;
      player.y += player.vy * dt;

      let landed = false;
      for (const plat of platforms) {
        const wasAbove = prevY + player.h <= plat.y + 2;
        const isFalling = player.vy >= 0;
        const withinX = player.x + player.w > plat.x && player.x < plat.x + plat.w;
        if (wasAbove && isFalling && withinX) {
          if (player.y + player.h >= plat.y) {
            player.y = plat.y - player.h;
            player.vy = 0;
            landed = true;
            break;
          }
        }
      }

      if (!landed && player.y + player.h >= world.groundY) {
        player.y = world.groundY - player.h;
        player.vy = 0;
        landed = true;
      }

      if (landed) {
        player.jumpsLeft = 1;
      }

      const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
      const kidBox = {
        x: state.kidX,
        y: state.kidY,
        w: 28,
        h: 48
      };
      if (state.billManActive && state.billManHp > 0) {
        const bossBox = {
          x: state.billManX - state.billManW * 0.5,
          y: state.billManY,
          w: state.billManW,
          h: state.billManH
        };
        if (rectsOverlap(playerBox, bossBox)) {
          state.deathCause = "enemy";
          die();
          return;
        }
      }
      for (let i = obstacles.length - 1; i >= 0; i -= 1) {
        const obs = obstacles[i];
        if (rectsOverlap(playerBox, obs)) {
          const playerFeet = player.y + player.h;
          const stompZone = obs.y + obs.h * 0.35;
          if (player.vy > 0 && playerFeet <= stompZone) {
            obstacles.splice(i, 1);
            player.vy = -state.jumpPower * 0.45;
            state.score += 10;
          } else {
            state.deathCause = "enemy";
            die();
            break;
          }
        }
        if (state.kidAlive && rectsOverlap(kidBox, obs)) {
          state.kidHits += 1;
          if (state.kidHits >= 3) {
            state.kidAlive = false;
          }
        }
      }

      for (let i = enemyShots.length - 1; i >= 0; i -= 1) {
        const shot = enemyShots[i];
        const dx = player.x + player.w * 0.5 - shot.x;
        const dy = player.y + player.h * 0.5 - shot.y;
        if (Math.hypot(dx, dy) < player.w * 0.4 + shot.r) {
          enemyShots.splice(i, 1);
          state.deathCause = "enemy";
          die();
          break;
        }
        if (state.kidAlive && Math.hypot(kidBox.x + 14 - shot.x, kidBox.y + 24 - shot.y) < 20 + shot.r) {
          enemyShots.splice(i, 1);
          state.kidHits += 1;
          if (state.kidHits >= 3) {
            state.kidAlive = false;
          }
        }
      }

      for (let i = billRockets.length - 1; i >= 0; i -= 1) {
        const rocket = billRockets[i];
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          if (Math.hypot(rocket.x - fb.x, rocket.y - fb.y) < rocket.r + fb.r + 4) {
            billRockets.splice(i, 1);
            fireballs.splice(j, 1);
            break;
          }
        }
      }

      for (let i = billFireballs.length - 1; i >= 0; i -= 1) {
        const shot = billFireballs[i];
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          if (Math.hypot(shot.x - fb.x, shot.y - fb.y) < shot.r + fb.r + 4) {
            billFireballs.splice(i, 1);
            fireballs.splice(j, 1);
            break;
          }
        }
      }
      for (let i = billRockets.length - 1; i >= 0; i -= 1) {
        const shot = billRockets[i];
        const dx = player.x + player.w * 0.5 - shot.x;
        const dy = player.y + player.h * 0.5 - shot.y;
        if (Math.hypot(dx, dy) < player.w * 0.4 + shot.r) {
          billRockets.splice(i, 1);
          state.deathCause = "enemy";
          die();
          break;
        }
        if (state.kidAlive && Math.hypot(kidBox.x + 14 - shot.x, kidBox.y + 24 - shot.y) < 20 + shot.r) {
          billRockets.splice(i, 1);
          state.kidHits += 1;
          if (state.kidHits >= 3) {
            state.kidAlive = false;
          }
        }
      }

      for (let i = billFireballs.length - 1; i >= 0; i -= 1) {
        const shot = billFireballs[i];
        const dx = player.x + player.w * 0.5 - shot.x;
        const dy = player.y + player.h * 0.5 - shot.y;
        if (Math.hypot(dx, dy) < player.w * 0.4 + shot.r) {
          billFireballs.splice(i, 1);
          state.deathCause = "enemy";
          die();
          break;
        }
        if (state.kidAlive && Math.hypot(kidBox.x + 14 - shot.x, kidBox.y + 24 - shot.y) < 20 + shot.r) {
          billFireballs.splice(i, 1);
          state.kidHits += 1;
          if (state.kidHits >= 3) {
            state.kidAlive = false;
          }
        }
      }

      for (let i = obstacles.length - 1; i >= 0; i -= 1) {
        const obs = obstacles[i];
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          const dx = obs.x + obs.w * 0.5 - fb.x;
          const dy = obs.y + obs.h * 0.5 - fb.y;
          if (Math.hypot(dx, dy) < obs.w * 0.6 + fb.r) {
            fireballs.splice(j, 1);
            obs.hp -= 1;
            if (obs.hp <= 0) {
              if (Math.random() < 0.2) {
                plants.push({
                  x: obs.x + obs.w * 0.5,
                  y: obs.y - 8,
                  r: 12
                });
              }
              obstacles.splice(i, 1);
              state.score += 8;
            }
            break;
          }
        }
      }

      if (state.billManActive && state.billManHp > 0) {
        for (let j = fireballs.length - 1; j >= 0; j -= 1) {
          const fb = fireballs[j];
          const bossCenterX = state.billManX;
          const bossCenterY = state.billManY + state.billManH * 0.5;
          const dx = bossCenterX - fb.x;
          const dy = bossCenterY - fb.y;
          if (Math.hypot(dx, dy) < 38 + fb.r) {
            fireballs.splice(j, 1);
            state.billManHp -= 1;
            if (state.billManHp <= 0) {
              state.billManActive = false;
              break;
            }
          }
        }
      }

      for (let i = collectibles.length - 1; i >= 0; i -= 1) {
        const item = collectibles[i];
        const dx = player.x + player.w / 2 - item.x;
        const dy = player.y + player.h / 2 - item.y;
        const dist = Math.hypot(dx, dy);
        if (dist < player.w * 0.6 + item.r) {
          collectibles.splice(i, 1);
          state.score += 15;
          state.meter = Math.min(100, state.meter + state.meterAdd);
          state.collectMessageTimer = 0.6;
          speakYeah();
        }
      }

      for (let i = plants.length - 1; i >= 0; i -= 1) {
        const plant = plants[i];
        const dx = player.x + player.w / 2 - plant.x;
        const dy = player.y + player.h / 2 - plant.y;
        const dist = Math.hypot(dx, dy);
        if (dist < player.w * 0.6 + plant.r) {
          plants.splice(i, 1);
          state.meter = 100;
          state.flameShots = 1;
          speakGreenThing();
        }
      }
    }

    function drawBackground() {
      ctx.clearRect(0, 0, world.width, world.height);

      const skylineY = world.height * 0.42;
      ctx.fillStyle = "rgba(10, 10, 18, 0.75)";
      ctx.fillRect(0, skylineY, world.width, world.height - skylineY);

      const layers = [
        { count: 8, height: 80, color: "rgba(32, 26, 44, 0.8)", offset: 0.4 },
        { count: 10, height: 120, color: "rgba(24, 22, 36, 0.85)", offset: 0.7 }
      ];

      layers.forEach((layer, index) => {
        const shift = (state.cameraX * 0.08 * (index + 1)) % 200;
        ctx.fillStyle = layer.color;
        for (let i = 0; i < layer.count; i += 1) {
          const width = 90 + (i % 3) * 40;
          const x = i * 140 - shift;
          const y = skylineY - layer.height - (i % 2) * 30;
          ctx.fillRect(x, y, width, layer.height + (i % 2) * 30);
        }
      });

      ctx.fillStyle = "#2c263a";
      ctx.fillRect(0, world.groundY, world.width, world.height - world.groundY);

      ctx.strokeStyle = "rgba(255, 255, 255, 0.08)";
      ctx.lineWidth = 2;
      for (let i = 0; i < 12; i += 1) {
        const x = ((state.cameraX * 0.2) % 220) + i * 220;
        ctx.beginPath();
        ctx.moveTo(x, world.groundY + 12);
        ctx.lineTo(x + 80, world.groundY + 12);
        ctx.stroke();
      }
    }

    function drawPlatform(plat) {
      ctx.fillStyle = "#8b4b2b";
      ctx.fillRect(plat.x, plat.y, plat.w, plat.h);

      ctx.strokeStyle = "rgba(255, 214, 160, 0.35)";
      ctx.lineWidth = 2;
      ctx.strokeRect(plat.x + 1, plat.y + 1, plat.w - 2, plat.h - 2);

      const brickW = 36;
      const brickH = 10;
      const rows = Math.max(1, Math.floor(plat.h / brickH));
      const cols = Math.max(1, Math.floor(plat.w / brickW));

      ctx.strokeStyle = "rgba(60, 26, 14, 0.6)";
      ctx.lineWidth = 1.5;
      for (let row = 0; row < rows; row += 1) {
        const y = plat.y + row * brickH;
        ctx.beginPath();
        ctx.moveTo(plat.x, y);
        ctx.lineTo(plat.x + plat.w, y);
        ctx.stroke();

        const offset = row % 2 === 0 ? 0 : brickW * 0.5;
        for (let col = 0; col <= cols; col += 1) {
          const x = plat.x + col * brickW - offset;
          if (x > plat.x && x < plat.x + plat.w) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + brickH);
            ctx.stroke();
          }
        }
      }
    }

    function drawTrapHouse() {
      const width = 180;
      const height = 140;
      const x = state.levelEndX - width * 0.5 - state.cameraX;
      const y = world.groundY - height;

      ctx.save();
      ctx.fillStyle = "#3a2436";
      ctx.fillRect(x, y, width, height);

      ctx.fillStyle = "#251823";
      ctx.fillRect(x + 18, y + 50, 50, 90);
      ctx.fillStyle = "#1a1016";
      ctx.fillRect(x + 30, y + 72, 12, 26);

      ctx.fillStyle = "#ffb200";
      ctx.fillRect(x + 86, y + 60, 70, 38);
      ctx.strokeStyle = "rgba(0, 0, 0, 0.6)";
      ctx.lineWidth = 2;
      ctx.strokeRect(x + 86, y + 60, 70, 38);

      ctx.fillStyle = "#0f0f14";
      ctx.font = "bold 15px \"Impact\", sans-serif";
      ctx.textAlign = "center";
      if (state.goalLabel === "ROACH MOTEL") {
        ctx.fillText("ROACH", x + width / 2, y + 22);
        ctx.fillText("MOTEL", x + width / 2, y + 38);
      } else {
        ctx.fillText("TRAP HOUSE", x + width / 2, y + 28);
      }
      ctx.restore();
    }

    function drawCourier() {
      const screenX = player.x - state.cameraX;
      const y = player.y;
      const w = player.w;
      const h = player.h;

      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#5b3a2a";
      ctx.beginPath();
      ctx.arc(w * 0.55, h * 0.18, w * 0.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#1b1b22";
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.32);
      ctx.lineTo(w * 0.9, h * 0.32);
      ctx.lineTo(w * 0.75, h * 0.95);
      ctx.lineTo(w * 0.25, h * 0.95);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "#2665ff";
      ctx.beginPath();
      ctx.moveTo(w * 0.25, h * 0.45);
      ctx.lineTo(w * 0.8, h * 0.4);
      ctx.lineTo(w * 0.7, h * 0.75);
      ctx.lineTo(w * 0.18, h * 0.8);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "#141018";
      ctx.fillRect(w * 0.08, h * 0.62, w * 0.42, h * 0.22);
      ctx.fillStyle = "#2f2737";
      ctx.fillRect(w * 0.12, h * 0.65, w * 0.34, h * 0.16);

      ctx.strokeStyle = "#ffd166";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.35);
      ctx.lineTo(w * 0.02, h * 0.7);
      ctx.stroke();

      ctx.fillStyle = "#0f0f14";
      ctx.fillRect(w * 0.62, h * 0.16, 6, 6);
      ctx.fillRect(w * 0.42, h * 0.16, 6, 6);

      ctx.strokeStyle = "#ffd166";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(w * 0.55, h * 0.34, w * 0.12, 0, Math.PI);
      ctx.stroke();

      ctx.fillStyle = "#0f0f14";
      ctx.fillRect(w * 0.22, h * 0.88, w * 0.18, h * 0.08);
      ctx.fillRect(w * 0.6, h * 0.88, w * 0.18, h * 0.08);

      ctx.restore();
    }

    function drawRoach(obs) {
      const screenX = obs.x - state.cameraX;
      const { y, w, h } = obs;
      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#4a2a1a";
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h * 0.55, w * 0.5, h * 0.45, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2a160c";
      ctx.beginPath();
      ctx.ellipse(w * 0.6, h * 0.45, w * 0.2, h * 0.28, 0.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#8a5a3a";
      ctx.lineWidth = 2;
      const stride = Math.sin(state.time * 8 + obs.phase) * 6;
      for (let i = 0; i < 3; i += 1) {
        const lx = w * 0.2 + i * w * 0.2;
        ctx.beginPath();
        ctx.moveTo(lx, h * 0.5);
        ctx.lineTo(lx - w * 0.15, h * 0.2 + stride);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(lx + w * 0.2, h * 0.55);
        ctx.lineTo(lx + w * 0.35, h * 0.8 - stride);
        ctx.stroke();
      }

      ctx.strokeStyle = "#cfa07a";
      ctx.beginPath();
      ctx.moveTo(w * 0.78, h * 0.25);
      ctx.lineTo(w * 0.95, h * 0.05);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w * 0.82, h * 0.35);
      ctx.lineTo(w * 1.0, h * 0.2);
      ctx.stroke();

      ctx.restore();
    }

    function drawHousingEnemy(obs) {
      const screenX = obs.x - state.cameraX;
      const { y, w, h } = obs;
      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#f1d6c7";
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.18, w * 0.22, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2c2b30";
      ctx.fillRect(w * 0.25, h * 0.35, w * 0.5, h * 0.5);

      ctx.fillStyle = "#1a1412";
      ctx.fillRect(w * 0.38, h * 0.85, w * 0.16, h * 0.15);
      ctx.fillRect(w * 0.56, h * 0.85, w * 0.16, h * 0.15);

      ctx.strokeStyle = "#e9dfd2";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.45);
      ctx.lineTo(w * 0.05, h * 0.8);
      ctx.stroke();

      ctx.fillStyle = "#f6f1e8";
      ctx.fillRect(w * 0.6, h * 0.2, w * 0.6, h * 0.4);
      ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
      ctx.lineWidth = 2;
      ctx.strokeRect(w * 0.6, h * 0.2, w * 0.6, h * 0.4);

      ctx.fillStyle = "#0f0f14";
      ctx.font = "bold 8px \"Trebuchet MS\", sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("HOUSING", w * 0.9, h * 0.35);
      ctx.fillText("AUTHORITY", w * 0.9, h * 0.48);

      ctx.restore();
    }

    function drawHelicopter(obs) {
      const screenX = obs.x - state.cameraX;
      const { y, w, h } = obs;
      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#3b3f4d";
      ctx.beginPath();
      ctx.ellipse(w * 0.5, h * 0.6, w * 0.5, h * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#1b1f28";
      ctx.fillRect(w * 0.2, h * 0.35, w * 0.5, h * 0.2);

      ctx.strokeStyle = "#d9d9d9";
      ctx.lineWidth = 3;
      const rotor = Math.sin(state.time * 12 + obs.phase) * 12;
      ctx.beginPath();
      ctx.moveTo(w * 0.5 - 30 - rotor, h * 0.2);
      ctx.lineTo(w * 0.5 + 30 + rotor, h * 0.2);
      ctx.stroke();

      ctx.strokeStyle = "#3b3f4d";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(w * 0.65, h * 0.55);
      ctx.lineTo(w * 0.9, h * 0.7);
      ctx.stroke();

      ctx.restore();
    }

    function drawBillMan() {
      if (!state.billManActive || state.billManHp <= 0) return;
      const w = state.billManW;
      const h = state.billManH;
      const screenX = state.billManX - state.cameraX;
      const y = state.billManY;

      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#f1d6c7";
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.18, w * 0.22, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#2c2b30";
      ctx.fillRect(w * 0.28, h * 0.32, w * 0.44, h * 0.5);

      ctx.fillStyle = "#1a1412";
      ctx.fillRect(w * 0.34, h * 0.82, w * 0.16, h * 0.16);
      ctx.fillRect(w * 0.56, h * 0.82, w * 0.16, h * 0.16);

      ctx.strokeStyle = "#e9dfd2";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(w * 0.2, h * 0.4);
      ctx.lineTo(w * 0.02, h * 0.8);
      ctx.stroke();

      ctx.fillStyle = "#f6f1e8";
      ctx.fillRect(w * 0.58, h * 0.15, w * 0.6, h * 0.38);
      ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
      ctx.lineWidth = 2;
      ctx.strokeRect(w * 0.58, h * 0.15, w * 0.6, h * 0.38);

      ctx.fillStyle = "#0f0f14";
      ctx.font = "bold 8px \"Trebuchet MS\", sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("BILL", w * 0.88, h * 0.3);
      ctx.fillText("MAN", w * 0.88, h * 0.42);

      ctx.restore();
    }

    function drawKid() {
      if (!state.kidAlive) return;
      const screenX = state.kidX - state.cameraX;
      const y = state.kidY;
      const w = 28;
      const h = 48;

      ctx.save();
      ctx.translate(screenX, y);

      ctx.fillStyle = "#c68f62";
      ctx.beginPath();
      ctx.arc(w * 0.5, h * 0.2, w * 0.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#1f1a28";
      ctx.fillRect(w * 0.22, h * 0.35, w * 0.56, h * 0.5);

      ctx.strokeStyle = "#111018";
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i += 1) {
        const x = w * 0.28 + i * 4;
        ctx.beginPath();
        ctx.moveTo(x, h * 0.06);
        ctx.lineTo(x, h * 0.18);
        ctx.stroke();
      }

      ctx.fillStyle = "#0f0f14";
      ctx.fillRect(w * 0.28, h * 0.82, w * 0.16, h * 0.14);
      ctx.fillRect(w * 0.56, h * 0.82, w * 0.16, h * 0.14);

      ctx.restore();
    }

    function drawCigarettes(item) {
      const screenX = item.x - state.cameraX;
      ctx.save();
      ctx.translate(screenX, item.y);
      const w = item.r * 2.8;
      const h = item.r * 0.9;

      ctx.fillStyle = "#f2efe6";
      ctx.beginPath();
      ctx.roundRect(-w / 2, -h / 2, w, h, 6);
      ctx.fill();

      ctx.fillStyle = "#d28a6a";
      ctx.fillRect(w * 0.2, -h / 2, w * 0.2, h);

      ctx.fillStyle = "#2a1d1d";
      ctx.fillRect(-w / 2, -h / 2, w * 0.08, h);

      ctx.strokeStyle = "rgba(255, 178, 0, 0.7)";
      ctx.lineWidth = 2;
      ctx.strokeRect(-w / 2, -h / 2, w, h);

      ctx.restore();
    }

    function drawPlant(plant) {
      const screenX = plant.x - state.cameraX;
      ctx.save();
      ctx.translate(screenX, plant.y);

      ctx.fillStyle = "#2fa84a";
      ctx.beginPath();
      ctx.moveTo(0, -plant.r * 1.1);
      ctx.lineTo(plant.r * 0.15, -plant.r * 0.4);
      ctx.lineTo(plant.r * 0.8, -plant.r * 0.9);
      ctx.lineTo(plant.r * 0.35, -plant.r * 0.1);
      ctx.lineTo(plant.r * 1.1, plant.r * 0.2);
      ctx.lineTo(plant.r * 0.3, plant.r * 0.15);
      ctx.lineTo(plant.r * 0.75, plant.r * 0.95);
      ctx.lineTo(0, plant.r * 0.35);
      ctx.lineTo(-plant.r * 0.75, plant.r * 0.95);
      ctx.lineTo(-plant.r * 0.3, plant.r * 0.15);
      ctx.lineTo(-plant.r * 1.1, plant.r * 0.2);
      ctx.lineTo(-plant.r * 0.35, -plant.r * 0.1);
      ctx.lineTo(-plant.r * 0.8, -plant.r * 0.9);
      ctx.lineTo(-plant.r * 0.15, -plant.r * 0.4);
      ctx.closePath();
      ctx.fill();

      ctx.strokeStyle = "rgba(0, 0, 0, 0.4)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, plant.r * 0.35);
      ctx.lineTo(0, -plant.r * 1.1);
      ctx.stroke();

      ctx.restore();
    }

    function draw() {
      drawBackground();

      for (const plat of platforms) {
        drawPlatform({
          x: plat.x - state.cameraX,
          y: plat.y,
          w: plat.w,
          h: plat.h
        });
      }

      ctx.shadowColor = "rgba(255, 178, 0, 0.35)";
      ctx.shadowBlur = 12;
      for (const item of collectibles) {
        drawCigarettes(item);
      }
      ctx.shadowBlur = 0;

      for (const obs of obstacles) {
        if (obs.type === "housing") {
          drawHousingEnemy(obs);
        } else if (obs.type === "heli") {
          drawHelicopter(obs);
        } else {
          drawRoach(obs);
        }
      }

      drawBillMan();

      ctx.fillStyle = "#ffb200";
      for (const fireball of fireballs) {
        const screenX = fireball.x - state.cameraX;
        ctx.beginPath();
        ctx.shadowColor = "rgba(255, 178, 0, 0.7)";
        ctx.shadowBlur = 10;
        ctx.arc(screenX, fireball.y, fireball.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      ctx.fillStyle = "#ff5a4f";
      for (const shot of enemyShots) {
        const screenX = shot.x - state.cameraX;
        ctx.beginPath();
        ctx.shadowColor = "rgba(255, 90, 79, 0.6)";
        ctx.shadowBlur = 8;
        ctx.arc(screenX, shot.y, shot.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      ctx.fillStyle = "#ff8f3d";
      for (const rocket of billRockets) {
        const screenX = rocket.x - state.cameraX;
        ctx.beginPath();
        ctx.shadowColor = "rgba(255, 143, 61, 0.6)";
        ctx.shadowBlur = 10;
        ctx.arc(screenX, rocket.y, rocket.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      ctx.fillStyle = "#ff5a4f";
      for (const shot of billFireballs) {
        const screenX = shot.x - state.cameraX;
        ctx.beginPath();
        ctx.shadowColor = "rgba(255, 90, 79, 0.6)";
        ctx.shadowBlur = 8;
        ctx.arc(screenX, shot.y, shot.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      for (const plant of plants) {
        drawPlant(plant);
      }

      drawTrapHouse();
      drawCourier();
      drawKid();

      if (state.collectMessageTimer > 0) {
        ctx.save();
        ctx.fillStyle = "#ffb200";
        ctx.font = "bold 18px \"Trebuchet MS\", sans-serif";
        ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
        ctx.shadowBlur = 6;
        const screenX = player.x - state.cameraX;
        ctx.fillText("yeah yeah", screenX + player.w * 0.2, player.y - 12);
        ctx.restore();
      }

      if (state.fireMessageTimer > 0) {
        ctx.save();
        ctx.fillStyle = "#ff5a4f";
        ctx.font = "bold 16px \"Trebuchet MS\", sans-serif";
        ctx.shadowColor = "rgba(0, 0, 0, 0.6)";
        ctx.shadowBlur = 6;
        const screenX = player.x - state.cameraX;
        ctx.fillText("EBT attack", screenX + player.w * 0.2, player.y - 34);
        ctx.restore();
      }

      if (state.beltTimer > 0) {
        const screenX = player.x - state.cameraX;
        const dir = player.facing || 1;
        ctx.save();
        ctx.strokeStyle = "#c9b08a";
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(screenX + player.w * 0.5, player.y + player.h * 0.5);
        ctx.lineTo(screenX + player.w * 0.5 + dir * 40, player.y + player.h * 0.35);
        ctx.stroke();
        ctx.restore();
      }
    }

    function loop(now) {
      const dt = Math.min(0.033, (now - state.lastFrame) / 1000);
      state.lastFrame = now;

      if (input.jumpQueued) {
        input.jumpQueued = false;
        handleJump();
      }
      if (input.fireQueued) {
        input.fireQueued = false;
        shootFireball();
      }
      if (input.beltQueued) {
        input.beltQueued = false;
        swingBelt();
      }

      update(dt);
      draw();

      hudScore.textContent = Math.floor(state.score).toString();
      const meterValue = Math.max(0, Math.min(100, state.meter));
      meterFill.style.width = `${meterValue}%`;
      meterText.textContent = `${Math.round(meterValue)}%`;
      if (meterValueLabel) {
        meterValueLabel.textContent = `${Math.round(meterValue)}%`;
      }

      if (state.collectMessageTimer > 0) {
        state.collectMessageTimer -= dt;
      }
      if (state.fireMessageTimer > 0) {
        state.fireMessageTimer -= dt;
      }
      if (state.beltTimer > 0) {
        state.beltTimer -= dt;
      }

      requestAnimationFrame(loop);
    }

    window.addEventListener("resize", () => {
      resize();
    });

    window.addEventListener("keydown", (event) => {
      hasUserInteracted = true;
      if (event.code === "Space" || event.code === "ArrowUp" || event.code === "KeyW") {
        event.preventDefault();
        queueJump();
        if (!state.spokenStart && state.running && !state.dead) {
          speakYeah();
          state.spokenStart = true;
        }
      }
      if (event.code === "KeyF") {
        queueFire();
      }
      if (event.code === "ArrowLeft" || event.code === "KeyA") {
        input.left = true;
      }
      if (event.code === "ArrowRight" || event.code === "KeyD") {
        input.right = true;
      }
      if (event.code === "KeyR" && state.dead) {
        resetGame();
      }
    });

    window.addEventListener("keyup", (event) => {
      if (event.code === "ArrowLeft" || event.code === "KeyA") {
        input.left = false;
      }
      if (event.code === "ArrowRight" || event.code === "KeyD") {
        input.right = false;
      }
    });

    canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });

    canvas.addEventListener("mousedown", (event) => {
      if (event.button === 2) {
        hasUserInteracted = true;
        queueBelt();
        return;
      }
      if (event.button !== 0) return;
      hasUserInteracted = true;
      queueFire();
    });

    if (fireBtn) {
      fireBtn.addEventListener("click", () => {
        hasUserInteracted = true;
        queueFire();
      });
    }

    if (beltBtn) {
      beltBtn.addEventListener("click", () => {
        hasUserInteracted = true;
        queueBelt();
      });
    }

    if (voiceToggle) {
      voiceToggle.addEventListener("click", () => {
        state.voiceEnabled = !state.voiceEnabled;
        voiceToggle.textContent = state.voiceEnabled ? "Voice On" : "Voice Off";
      });
    }

    if (restartBtn) {
      restartBtn.addEventListener("click", () => {
        hasUserInteracted = true;
        if (state.deathCause === "win") {
          resetGame(state.level === 1 ? 2 : 1);
        } else {
          resetGame(state.level);
        }
      });
    }

    if (isTouch) {
      canvas.addEventListener("pointerdown", (event) => {
        hasUserInteracted = true;
        touchMove.active = true;
        touchMove.id = event.pointerId;
        touchMove.startX = event.clientX;
        touchMove.lastX = event.clientX;
        touchMove.moved = false;
      });

      canvas.addEventListener("pointermove", (event) => {
        if (!touchMove.active || event.pointerId !== touchMove.id) return;
        const dx = event.clientX - touchMove.startX;
        touchMove.lastX = event.clientX;
        if (Math.abs(dx) > 12) {
          touchMove.moved = true;
          input.left = dx < -12;
          input.right = dx > 12;
        } else {
          input.left = false;
          input.right = false;
        }
      });

      canvas.addEventListener("pointerup", (event) => {
        if (event.pointerId !== touchMove.id) return;
        if (!touchMove.moved) {
          queueJump();
          if (!state.spokenStart && state.running && !state.dead) {
            speakYeah();
            state.spokenStart = true;
          }
        }
        input.left = false;
        input.right = false;
        touchMove.active = false;
        touchMove.id = null;
      });

      canvas.addEventListener("pointercancel", () => {
        input.left = false;
        input.right = false;
        touchMove.active = false;
        touchMove.id = null;
      });
    }

    resize();
    resetGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
